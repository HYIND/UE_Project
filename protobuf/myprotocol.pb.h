// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: myprotocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_myprotocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_myprotocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_myprotocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_myprotocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_myprotocol_2eproto;
namespace Message {
class Game_brick_hited_Response;
struct Game_brick_hited_ResponseDefaultTypeInternal;
extern Game_brick_hited_ResponseDefaultTypeInternal _Game_brick_hited_Response_default_instance_;
class Game_bulletinfo_Request;
struct Game_bulletinfo_RequestDefaultTypeInternal;
extern Game_bulletinfo_RequestDefaultTypeInternal _Game_bulletinfo_Request_default_instance_;
class Game_bulletinfo_Response;
struct Game_bulletinfo_ResponseDefaultTypeInternal;
extern Game_bulletinfo_ResponseDefaultTypeInternal _Game_bulletinfo_Response_default_instance_;
class Game_bulletinfo_Response_Info;
struct Game_bulletinfo_Response_InfoDefaultTypeInternal;
extern Game_bulletinfo_Response_InfoDefaultTypeInternal _Game_bulletinfo_Response_Info_default_instance_;
class Game_create_prop;
struct Game_create_propDefaultTypeInternal;
extern Game_create_propDefaultTypeInternal _Game_create_prop_default_instance_;
class Game_destroyed_tank_Response;
struct Game_destroyed_tank_ResponseDefaultTypeInternal;
extern Game_destroyed_tank_ResponseDefaultTypeInternal _Game_destroyed_tank_Response_default_instance_;
class Game_getProp_Request;
struct Game_getProp_RequestDefaultTypeInternal;
extern Game_getProp_RequestDefaultTypeInternal _Game_getProp_Request_default_instance_;
class Game_hit_brick_Request;
struct Game_hit_brick_RequestDefaultTypeInternal;
extern Game_hit_brick_RequestDefaultTypeInternal _Game_hit_brick_Request_default_instance_;
class Game_hit_tank_Request;
struct Game_hit_tank_RequestDefaultTypeInternal;
extern Game_hit_tank_RequestDefaultTypeInternal _Game_hit_tank_Request_default_instance_;
class Game_prop_Response;
struct Game_prop_ResponseDefaultTypeInternal;
extern Game_prop_ResponseDefaultTypeInternal _Game_prop_Response_default_instance_;
class Game_tank_hited_Response;
struct Game_tank_hited_ResponseDefaultTypeInternal;
extern Game_tank_hited_ResponseDefaultTypeInternal _Game_tank_hited_Response_default_instance_;
class Game_tankinfo_Request;
struct Game_tankinfo_RequestDefaultTypeInternal;
extern Game_tankinfo_RequestDefaultTypeInternal _Game_tankinfo_Request_default_instance_;
class Game_tankinfo_Response;
struct Game_tankinfo_ResponseDefaultTypeInternal;
extern Game_tankinfo_ResponseDefaultTypeInternal _Game_tankinfo_Response_default_instance_;
class Game_tankinfo_Response_tankinfo;
struct Game_tankinfo_Response_tankinfoDefaultTypeInternal;
extern Game_tankinfo_Response_tankinfoDefaultTypeInternal _Game_tankinfo_Response_tankinfo_default_instance_;
class Hall_EnterRoom_Request;
struct Hall_EnterRoom_RequestDefaultTypeInternal;
extern Hall_EnterRoom_RequestDefaultTypeInternal _Hall_EnterRoom_Request_default_instance_;
class Hall_EnterRoom_Response;
struct Hall_EnterRoom_ResponseDefaultTypeInternal;
extern Hall_EnterRoom_ResponseDefaultTypeInternal _Hall_EnterRoom_Response_default_instance_;
class Hall_Message_Request;
struct Hall_Message_RequestDefaultTypeInternal;
extern Hall_Message_RequestDefaultTypeInternal _Hall_Message_Request_default_instance_;
class Hall_Message_Response;
struct Hall_Message_ResponseDefaultTypeInternal;
extern Hall_Message_ResponseDefaultTypeInternal _Hall_Message_Response_default_instance_;
class Hall_info_Response;
struct Hall_info_ResponseDefaultTypeInternal;
extern Hall_info_ResponseDefaultTypeInternal _Hall_info_Response_default_instance_;
class Hall_info_Response_Roominfo;
struct Hall_info_Response_RoominfoDefaultTypeInternal;
extern Hall_info_Response_RoominfoDefaultTypeInternal _Hall_info_Response_Roominfo_default_instance_;
class Hall_info_Response_User;
struct Hall_info_Response_UserDefaultTypeInternal;
extern Hall_info_Response_UserDefaultTypeInternal _Hall_info_Response_User_default_instance_;
class Ping_info;
struct Ping_infoDefaultTypeInternal;
extern Ping_infoDefaultTypeInternal _Ping_info_default_instance_;
class Room_Message_Request;
struct Room_Message_RequestDefaultTypeInternal;
extern Room_Message_RequestDefaultTypeInternal _Room_Message_Request_default_instance_;
class Room_Message_Response;
struct Room_Message_ResponseDefaultTypeInternal;
extern Room_Message_ResponseDefaultTypeInternal _Room_Message_Response_default_instance_;
class Room_Set_tankid;
struct Room_Set_tankidDefaultTypeInternal;
extern Room_Set_tankidDefaultTypeInternal _Room_Set_tankid_default_instance_;
class Room_Set_tankid_Response;
struct Room_Set_tankid_ResponseDefaultTypeInternal;
extern Room_Set_tankid_ResponseDefaultTypeInternal _Room_Set_tankid_Response_default_instance_;
class Room_Start_Response;
struct Room_Start_ResponseDefaultTypeInternal;
extern Room_Start_ResponseDefaultTypeInternal _Room_Start_Response_default_instance_;
class Room_info_Response;
struct Room_info_ResponseDefaultTypeInternal;
extern Room_info_ResponseDefaultTypeInternal _Room_info_Response_default_instance_;
class Room_info_Response_User;
struct Room_info_Response_UserDefaultTypeInternal;
extern Room_info_Response_UserDefaultTypeInternal _Room_info_Response_User_default_instance_;
class Set_User_id;
struct Set_User_idDefaultTypeInternal;
extern Set_User_idDefaultTypeInternal _Set_User_id_default_instance_;
class UDP_INFO_REQ;
struct UDP_INFO_REQDefaultTypeInternal;
extern UDP_INFO_REQDefaultTypeInternal _UDP_INFO_REQ_default_instance_;
class UDP_INFO_RES;
struct UDP_INFO_RESDefaultTypeInternal;
extern UDP_INFO_RESDefaultTypeInternal _UDP_INFO_RES_default_instance_;
class bulletinfo;
struct bulletinfoDefaultTypeInternal;
extern bulletinfoDefaultTypeInternal _bulletinfo_default_instance_;
}  // namespace Message
PROTOBUF_NAMESPACE_OPEN
template<> ::Message::Game_brick_hited_Response* Arena::CreateMaybeMessage<::Message::Game_brick_hited_Response>(Arena*);
template<> ::Message::Game_bulletinfo_Request* Arena::CreateMaybeMessage<::Message::Game_bulletinfo_Request>(Arena*);
template<> ::Message::Game_bulletinfo_Response* Arena::CreateMaybeMessage<::Message::Game_bulletinfo_Response>(Arena*);
template<> ::Message::Game_bulletinfo_Response_Info* Arena::CreateMaybeMessage<::Message::Game_bulletinfo_Response_Info>(Arena*);
template<> ::Message::Game_create_prop* Arena::CreateMaybeMessage<::Message::Game_create_prop>(Arena*);
template<> ::Message::Game_destroyed_tank_Response* Arena::CreateMaybeMessage<::Message::Game_destroyed_tank_Response>(Arena*);
template<> ::Message::Game_getProp_Request* Arena::CreateMaybeMessage<::Message::Game_getProp_Request>(Arena*);
template<> ::Message::Game_hit_brick_Request* Arena::CreateMaybeMessage<::Message::Game_hit_brick_Request>(Arena*);
template<> ::Message::Game_hit_tank_Request* Arena::CreateMaybeMessage<::Message::Game_hit_tank_Request>(Arena*);
template<> ::Message::Game_prop_Response* Arena::CreateMaybeMessage<::Message::Game_prop_Response>(Arena*);
template<> ::Message::Game_tank_hited_Response* Arena::CreateMaybeMessage<::Message::Game_tank_hited_Response>(Arena*);
template<> ::Message::Game_tankinfo_Request* Arena::CreateMaybeMessage<::Message::Game_tankinfo_Request>(Arena*);
template<> ::Message::Game_tankinfo_Response* Arena::CreateMaybeMessage<::Message::Game_tankinfo_Response>(Arena*);
template<> ::Message::Game_tankinfo_Response_tankinfo* Arena::CreateMaybeMessage<::Message::Game_tankinfo_Response_tankinfo>(Arena*);
template<> ::Message::Hall_EnterRoom_Request* Arena::CreateMaybeMessage<::Message::Hall_EnterRoom_Request>(Arena*);
template<> ::Message::Hall_EnterRoom_Response* Arena::CreateMaybeMessage<::Message::Hall_EnterRoom_Response>(Arena*);
template<> ::Message::Hall_Message_Request* Arena::CreateMaybeMessage<::Message::Hall_Message_Request>(Arena*);
template<> ::Message::Hall_Message_Response* Arena::CreateMaybeMessage<::Message::Hall_Message_Response>(Arena*);
template<> ::Message::Hall_info_Response* Arena::CreateMaybeMessage<::Message::Hall_info_Response>(Arena*);
template<> ::Message::Hall_info_Response_Roominfo* Arena::CreateMaybeMessage<::Message::Hall_info_Response_Roominfo>(Arena*);
template<> ::Message::Hall_info_Response_User* Arena::CreateMaybeMessage<::Message::Hall_info_Response_User>(Arena*);
template<> ::Message::Ping_info* Arena::CreateMaybeMessage<::Message::Ping_info>(Arena*);
template<> ::Message::Room_Message_Request* Arena::CreateMaybeMessage<::Message::Room_Message_Request>(Arena*);
template<> ::Message::Room_Message_Response* Arena::CreateMaybeMessage<::Message::Room_Message_Response>(Arena*);
template<> ::Message::Room_Set_tankid* Arena::CreateMaybeMessage<::Message::Room_Set_tankid>(Arena*);
template<> ::Message::Room_Set_tankid_Response* Arena::CreateMaybeMessage<::Message::Room_Set_tankid_Response>(Arena*);
template<> ::Message::Room_Start_Response* Arena::CreateMaybeMessage<::Message::Room_Start_Response>(Arena*);
template<> ::Message::Room_info_Response* Arena::CreateMaybeMessage<::Message::Room_info_Response>(Arena*);
template<> ::Message::Room_info_Response_User* Arena::CreateMaybeMessage<::Message::Room_info_Response_User>(Arena*);
template<> ::Message::Set_User_id* Arena::CreateMaybeMessage<::Message::Set_User_id>(Arena*);
template<> ::Message::UDP_INFO_REQ* Arena::CreateMaybeMessage<::Message::UDP_INFO_REQ>(Arena*);
template<> ::Message::UDP_INFO_RES* Arena::CreateMaybeMessage<::Message::UDP_INFO_RES>(Arena*);
template<> ::Message::bulletinfo* Arena::CreateMaybeMessage<::Message::bulletinfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Message {

// ===================================================================

class Hall_info_Response_User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Hall_info_Response.User) */ {
 public:
  inline Hall_info_Response_User() : Hall_info_Response_User(nullptr) {}
  ~Hall_info_Response_User() override;
  explicit PROTOBUF_CONSTEXPR Hall_info_Response_User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Hall_info_Response_User(const Hall_info_Response_User& from);
  Hall_info_Response_User(Hall_info_Response_User&& from) noexcept
    : Hall_info_Response_User() {
    *this = ::std::move(from);
  }

  inline Hall_info_Response_User& operator=(const Hall_info_Response_User& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hall_info_Response_User& operator=(Hall_info_Response_User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hall_info_Response_User& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hall_info_Response_User* internal_default_instance() {
    return reinterpret_cast<const Hall_info_Response_User*>(
               &_Hall_info_Response_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Hall_info_Response_User& a, Hall_info_Response_User& b) {
    a.Swap(&b);
  }
  inline void Swap(Hall_info_Response_User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hall_info_Response_User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hall_info_Response_User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hall_info_Response_User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Hall_info_Response_User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Hall_info_Response_User& from) {
    Hall_info_Response_User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hall_info_Response_User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Hall_info_Response.User";
  }
  protected:
  explicit Hall_info_Response_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Message.Hall_info_Response.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Hall_info_Response_Roominfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Hall_info_Response.Roominfo) */ {
 public:
  inline Hall_info_Response_Roominfo() : Hall_info_Response_Roominfo(nullptr) {}
  ~Hall_info_Response_Roominfo() override;
  explicit PROTOBUF_CONSTEXPR Hall_info_Response_Roominfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Hall_info_Response_Roominfo(const Hall_info_Response_Roominfo& from);
  Hall_info_Response_Roominfo(Hall_info_Response_Roominfo&& from) noexcept
    : Hall_info_Response_Roominfo() {
    *this = ::std::move(from);
  }

  inline Hall_info_Response_Roominfo& operator=(const Hall_info_Response_Roominfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hall_info_Response_Roominfo& operator=(Hall_info_Response_Roominfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hall_info_Response_Roominfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hall_info_Response_Roominfo* internal_default_instance() {
    return reinterpret_cast<const Hall_info_Response_Roominfo*>(
               &_Hall_info_Response_Roominfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Hall_info_Response_Roominfo& a, Hall_info_Response_Roominfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Hall_info_Response_Roominfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hall_info_Response_Roominfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hall_info_Response_Roominfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hall_info_Response_Roominfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Hall_info_Response_Roominfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Hall_info_Response_Roominfo& from) {
    Hall_info_Response_Roominfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hall_info_Response_Roominfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Hall_info_Response.Roominfo";
  }
  protected:
  explicit Hall_info_Response_Roominfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostNameFieldNumber = 2,
    kRoomIdFieldNumber = 1,
  };
  // string host_name = 2;
  void clear_host_name();
  const std::string& host_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host_name();
  PROTOBUF_NODISCARD std::string* release_host_name();
  void set_allocated_host_name(std::string* host_name);
  private:
  const std::string& _internal_host_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host_name(const std::string& value);
  std::string* _internal_mutable_host_name();
  public:

  // int32 room_id = 1;
  void clear_room_id();
  int32_t room_id() const;
  void set_room_id(int32_t value);
  private:
  int32_t _internal_room_id() const;
  void _internal_set_room_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Hall_info_Response.Roominfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_name_;
    int32_t room_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Hall_info_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Hall_info_Response) */ {
 public:
  inline Hall_info_Response() : Hall_info_Response(nullptr) {}
  ~Hall_info_Response() override;
  explicit PROTOBUF_CONSTEXPR Hall_info_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Hall_info_Response(const Hall_info_Response& from);
  Hall_info_Response(Hall_info_Response&& from) noexcept
    : Hall_info_Response() {
    *this = ::std::move(from);
  }

  inline Hall_info_Response& operator=(const Hall_info_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hall_info_Response& operator=(Hall_info_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hall_info_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hall_info_Response* internal_default_instance() {
    return reinterpret_cast<const Hall_info_Response*>(
               &_Hall_info_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Hall_info_Response& a, Hall_info_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Hall_info_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hall_info_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hall_info_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hall_info_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Hall_info_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Hall_info_Response& from) {
    Hall_info_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hall_info_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Hall_info_Response";
  }
  protected:
  explicit Hall_info_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Hall_info_Response_User User;
  typedef Hall_info_Response_Roominfo Roominfo;

  // accessors -------------------------------------------------------

  enum : int {
    kUserinfoFieldNumber = 1,
    kRoominfoFieldNumber = 2,
  };
  // repeated .Message.Hall_info_Response.User userinfo = 1;
  int userinfo_size() const;
  private:
  int _internal_userinfo_size() const;
  public:
  void clear_userinfo();
  ::Message::Hall_info_Response_User* mutable_userinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Hall_info_Response_User >*
      mutable_userinfo();
  private:
  const ::Message::Hall_info_Response_User& _internal_userinfo(int index) const;
  ::Message::Hall_info_Response_User* _internal_add_userinfo();
  public:
  const ::Message::Hall_info_Response_User& userinfo(int index) const;
  ::Message::Hall_info_Response_User* add_userinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Hall_info_Response_User >&
      userinfo() const;

  // repeated .Message.Hall_info_Response.Roominfo roominfo = 2;
  int roominfo_size() const;
  private:
  int _internal_roominfo_size() const;
  public:
  void clear_roominfo();
  ::Message::Hall_info_Response_Roominfo* mutable_roominfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Hall_info_Response_Roominfo >*
      mutable_roominfo();
  private:
  const ::Message::Hall_info_Response_Roominfo& _internal_roominfo(int index) const;
  ::Message::Hall_info_Response_Roominfo* _internal_add_roominfo();
  public:
  const ::Message::Hall_info_Response_Roominfo& roominfo(int index) const;
  ::Message::Hall_info_Response_Roominfo* add_roominfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Hall_info_Response_Roominfo >&
      roominfo() const;

  // @@protoc_insertion_point(class_scope:Message.Hall_info_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Hall_info_Response_User > userinfo_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Hall_info_Response_Roominfo > roominfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Hall_Message_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Hall_Message_Request) */ {
 public:
  inline Hall_Message_Request() : Hall_Message_Request(nullptr) {}
  ~Hall_Message_Request() override;
  explicit PROTOBUF_CONSTEXPR Hall_Message_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Hall_Message_Request(const Hall_Message_Request& from);
  Hall_Message_Request(Hall_Message_Request&& from) noexcept
    : Hall_Message_Request() {
    *this = ::std::move(from);
  }

  inline Hall_Message_Request& operator=(const Hall_Message_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hall_Message_Request& operator=(Hall_Message_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hall_Message_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hall_Message_Request* internal_default_instance() {
    return reinterpret_cast<const Hall_Message_Request*>(
               &_Hall_Message_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Hall_Message_Request& a, Hall_Message_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Hall_Message_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hall_Message_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hall_Message_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hall_Message_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Hall_Message_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Hall_Message_Request& from) {
    Hall_Message_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hall_Message_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Hall_Message_Request";
  }
  protected:
  explicit Hall_Message_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // string content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:Message.Hall_Message_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Hall_Message_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Hall_Message_Response) */ {
 public:
  inline Hall_Message_Response() : Hall_Message_Response(nullptr) {}
  ~Hall_Message_Response() override;
  explicit PROTOBUF_CONSTEXPR Hall_Message_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Hall_Message_Response(const Hall_Message_Response& from);
  Hall_Message_Response(Hall_Message_Response&& from) noexcept
    : Hall_Message_Response() {
    *this = ::std::move(from);
  }

  inline Hall_Message_Response& operator=(const Hall_Message_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hall_Message_Response& operator=(Hall_Message_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hall_Message_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hall_Message_Response* internal_default_instance() {
    return reinterpret_cast<const Hall_Message_Response*>(
               &_Hall_Message_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Hall_Message_Response& a, Hall_Message_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Hall_Message_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hall_Message_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hall_Message_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hall_Message_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Hall_Message_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Hall_Message_Response& from) {
    Hall_Message_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hall_Message_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Hall_Message_Response";
  }
  protected:
  explicit Hall_Message_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:Message.Hall_Message_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Hall_EnterRoom_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Hall_EnterRoom_Request) */ {
 public:
  inline Hall_EnterRoom_Request() : Hall_EnterRoom_Request(nullptr) {}
  ~Hall_EnterRoom_Request() override;
  explicit PROTOBUF_CONSTEXPR Hall_EnterRoom_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Hall_EnterRoom_Request(const Hall_EnterRoom_Request& from);
  Hall_EnterRoom_Request(Hall_EnterRoom_Request&& from) noexcept
    : Hall_EnterRoom_Request() {
    *this = ::std::move(from);
  }

  inline Hall_EnterRoom_Request& operator=(const Hall_EnterRoom_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hall_EnterRoom_Request& operator=(Hall_EnterRoom_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hall_EnterRoom_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hall_EnterRoom_Request* internal_default_instance() {
    return reinterpret_cast<const Hall_EnterRoom_Request*>(
               &_Hall_EnterRoom_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Hall_EnterRoom_Request& a, Hall_EnterRoom_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Hall_EnterRoom_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hall_EnterRoom_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hall_EnterRoom_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hall_EnterRoom_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Hall_EnterRoom_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Hall_EnterRoom_Request& from) {
    Hall_EnterRoom_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hall_EnterRoom_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Hall_EnterRoom_Request";
  }
  protected:
  explicit Hall_EnterRoom_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
  };
  // int32 room_id = 1;
  void clear_room_id();
  int32_t room_id() const;
  void set_room_id(int32_t value);
  private:
  int32_t _internal_room_id() const;
  void _internal_set_room_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Hall_EnterRoom_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t room_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Hall_EnterRoom_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Hall_EnterRoom_Response) */ {
 public:
  inline Hall_EnterRoom_Response() : Hall_EnterRoom_Response(nullptr) {}
  ~Hall_EnterRoom_Response() override;
  explicit PROTOBUF_CONSTEXPR Hall_EnterRoom_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Hall_EnterRoom_Response(const Hall_EnterRoom_Response& from);
  Hall_EnterRoom_Response(Hall_EnterRoom_Response&& from) noexcept
    : Hall_EnterRoom_Response() {
    *this = ::std::move(from);
  }

  inline Hall_EnterRoom_Response& operator=(const Hall_EnterRoom_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Hall_EnterRoom_Response& operator=(Hall_EnterRoom_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Hall_EnterRoom_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Hall_EnterRoom_Response* internal_default_instance() {
    return reinterpret_cast<const Hall_EnterRoom_Response*>(
               &_Hall_EnterRoom_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Hall_EnterRoom_Response& a, Hall_EnterRoom_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Hall_EnterRoom_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Hall_EnterRoom_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Hall_EnterRoom_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Hall_EnterRoom_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Hall_EnterRoom_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Hall_EnterRoom_Response& from) {
    Hall_EnterRoom_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Hall_EnterRoom_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Hall_EnterRoom_Response";
  }
  protected:
  explicit Hall_EnterRoom_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIdFieldNumber = 1,
    kResultFieldNumber = 2,
  };
  // int32 room_id = 1;
  void clear_room_id();
  int32_t room_id() const;
  void set_room_id(int32_t value);
  private:
  int32_t _internal_room_id() const;
  void _internal_set_room_id(int32_t value);
  public:

  // int32 result = 2;
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Hall_EnterRoom_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t room_id_;
    int32_t result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Ping_info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Ping_info) */ {
 public:
  inline Ping_info() : Ping_info(nullptr) {}
  ~Ping_info() override;
  explicit PROTOBUF_CONSTEXPR Ping_info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ping_info(const Ping_info& from);
  Ping_info(Ping_info&& from) noexcept
    : Ping_info() {
    *this = ::std::move(from);
  }

  inline Ping_info& operator=(const Ping_info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping_info& operator=(Ping_info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping_info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping_info* internal_default_instance() {
    return reinterpret_cast<const Ping_info*>(
               &_Ping_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Ping_info& a, Ping_info& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping_info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping_info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping_info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ping_info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ping_info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ping_info& from) {
    Ping_info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ping_info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Ping_info";
  }
  protected:
  explicit Ping_info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPingIdFieldNumber = 1,
  };
  // int32 ping_id = 1;
  void clear_ping_id();
  int32_t ping_id() const;
  void set_ping_id(int32_t value);
  private:
  int32_t _internal_ping_id() const;
  void _internal_set_ping_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Ping_info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t ping_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Set_User_id final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Set_User_id) */ {
 public:
  inline Set_User_id() : Set_User_id(nullptr) {}
  ~Set_User_id() override;
  explicit PROTOBUF_CONSTEXPR Set_User_id(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Set_User_id(const Set_User_id& from);
  Set_User_id(Set_User_id&& from) noexcept
    : Set_User_id() {
    *this = ::std::move(from);
  }

  inline Set_User_id& operator=(const Set_User_id& from) {
    CopyFrom(from);
    return *this;
  }
  inline Set_User_id& operator=(Set_User_id&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Set_User_id& default_instance() {
    return *internal_default_instance();
  }
  static inline const Set_User_id* internal_default_instance() {
    return reinterpret_cast<const Set_User_id*>(
               &_Set_User_id_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Set_User_id& a, Set_User_id& b) {
    a.Swap(&b);
  }
  inline void Swap(Set_User_id* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Set_User_id* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Set_User_id* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Set_User_id>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Set_User_id& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Set_User_id& from) {
    Set_User_id::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Set_User_id* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Set_User_id";
  }
  protected:
  explicit Set_User_id(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Message.Set_User_id)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Room_info_Response_User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Room_info_Response.User) */ {
 public:
  inline Room_info_Response_User() : Room_info_Response_User(nullptr) {}
  ~Room_info_Response_User() override;
  explicit PROTOBUF_CONSTEXPR Room_info_Response_User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Room_info_Response_User(const Room_info_Response_User& from);
  Room_info_Response_User(Room_info_Response_User&& from) noexcept
    : Room_info_Response_User() {
    *this = ::std::move(from);
  }

  inline Room_info_Response_User& operator=(const Room_info_Response_User& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room_info_Response_User& operator=(Room_info_Response_User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Room_info_Response_User& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room_info_Response_User* internal_default_instance() {
    return reinterpret_cast<const Room_info_Response_User*>(
               &_Room_info_Response_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Room_info_Response_User& a, Room_info_Response_User& b) {
    a.Swap(&b);
  }
  inline void Swap(Room_info_Response_User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room_info_Response_User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room_info_Response_User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room_info_Response_User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Room_info_Response_User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Room_info_Response_User& from) {
    Room_info_Response_User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Room_info_Response_User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Room_info_Response.User";
  }
  protected:
  explicit Room_info_Response_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 status = 2;
  void clear_status();
  int32_t status() const;
  void set_status(int32_t value);
  private:
  int32_t _internal_status() const;
  void _internal_set_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Room_info_Response.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int32_t status_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Room_info_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Room_info_Response) */ {
 public:
  inline Room_info_Response() : Room_info_Response(nullptr) {}
  ~Room_info_Response() override;
  explicit PROTOBUF_CONSTEXPR Room_info_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Room_info_Response(const Room_info_Response& from);
  Room_info_Response(Room_info_Response&& from) noexcept
    : Room_info_Response() {
    *this = ::std::move(from);
  }

  inline Room_info_Response& operator=(const Room_info_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room_info_Response& operator=(Room_info_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Room_info_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room_info_Response* internal_default_instance() {
    return reinterpret_cast<const Room_info_Response*>(
               &_Room_info_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Room_info_Response& a, Room_info_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Room_info_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room_info_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room_info_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room_info_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Room_info_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Room_info_Response& from) {
    Room_info_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Room_info_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Room_info_Response";
  }
  protected:
  explicit Room_info_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Room_info_Response_User User;

  // accessors -------------------------------------------------------

  enum : int {
    kUserinfoFieldNumber = 1,
  };
  // repeated .Message.Room_info_Response.User userinfo = 1;
  int userinfo_size() const;
  private:
  int _internal_userinfo_size() const;
  public:
  void clear_userinfo();
  ::Message::Room_info_Response_User* mutable_userinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Room_info_Response_User >*
      mutable_userinfo();
  private:
  const ::Message::Room_info_Response_User& _internal_userinfo(int index) const;
  ::Message::Room_info_Response_User* _internal_add_userinfo();
  public:
  const ::Message::Room_info_Response_User& userinfo(int index) const;
  ::Message::Room_info_Response_User* add_userinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Room_info_Response_User >&
      userinfo() const;

  // @@protoc_insertion_point(class_scope:Message.Room_info_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Room_info_Response_User > userinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Room_Message_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Room_Message_Request) */ {
 public:
  inline Room_Message_Request() : Room_Message_Request(nullptr) {}
  ~Room_Message_Request() override;
  explicit PROTOBUF_CONSTEXPR Room_Message_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Room_Message_Request(const Room_Message_Request& from);
  Room_Message_Request(Room_Message_Request&& from) noexcept
    : Room_Message_Request() {
    *this = ::std::move(from);
  }

  inline Room_Message_Request& operator=(const Room_Message_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room_Message_Request& operator=(Room_Message_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Room_Message_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room_Message_Request* internal_default_instance() {
    return reinterpret_cast<const Room_Message_Request*>(
               &_Room_Message_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Room_Message_Request& a, Room_Message_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Room_Message_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room_Message_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room_Message_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room_Message_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Room_Message_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Room_Message_Request& from) {
    Room_Message_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Room_Message_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Room_Message_Request";
  }
  protected:
  explicit Room_Message_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
  };
  // string content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:Message.Room_Message_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Room_Message_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Room_Message_Response) */ {
 public:
  inline Room_Message_Response() : Room_Message_Response(nullptr) {}
  ~Room_Message_Response() override;
  explicit PROTOBUF_CONSTEXPR Room_Message_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Room_Message_Response(const Room_Message_Response& from);
  Room_Message_Response(Room_Message_Response&& from) noexcept
    : Room_Message_Response() {
    *this = ::std::move(from);
  }

  inline Room_Message_Response& operator=(const Room_Message_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room_Message_Response& operator=(Room_Message_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Room_Message_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room_Message_Response* internal_default_instance() {
    return reinterpret_cast<const Room_Message_Response*>(
               &_Room_Message_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Room_Message_Response& a, Room_Message_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Room_Message_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room_Message_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room_Message_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room_Message_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Room_Message_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Room_Message_Response& from) {
    Room_Message_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Room_Message_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Room_Message_Response";
  }
  protected:
  explicit Room_Message_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // @@protoc_insertion_point(class_scope:Message.Room_Message_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Room_Set_tankid final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Room_Set_tankid) */ {
 public:
  inline Room_Set_tankid() : Room_Set_tankid(nullptr) {}
  ~Room_Set_tankid() override;
  explicit PROTOBUF_CONSTEXPR Room_Set_tankid(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Room_Set_tankid(const Room_Set_tankid& from);
  Room_Set_tankid(Room_Set_tankid&& from) noexcept
    : Room_Set_tankid() {
    *this = ::std::move(from);
  }

  inline Room_Set_tankid& operator=(const Room_Set_tankid& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room_Set_tankid& operator=(Room_Set_tankid&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Room_Set_tankid& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room_Set_tankid* internal_default_instance() {
    return reinterpret_cast<const Room_Set_tankid*>(
               &_Room_Set_tankid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(Room_Set_tankid& a, Room_Set_tankid& b) {
    a.Swap(&b);
  }
  inline void Swap(Room_Set_tankid* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room_Set_tankid* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room_Set_tankid* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room_Set_tankid>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Room_Set_tankid& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Room_Set_tankid& from) {
    Room_Set_tankid::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Room_Set_tankid* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Room_Set_tankid";
  }
  protected:
  explicit Room_Set_tankid(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Room_Set_tankid)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Room_Set_tankid_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Room_Set_tankid_Response) */ {
 public:
  inline Room_Set_tankid_Response() : Room_Set_tankid_Response(nullptr) {}
  ~Room_Set_tankid_Response() override;
  explicit PROTOBUF_CONSTEXPR Room_Set_tankid_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Room_Set_tankid_Response(const Room_Set_tankid_Response& from);
  Room_Set_tankid_Response(Room_Set_tankid_Response&& from) noexcept
    : Room_Set_tankid_Response() {
    *this = ::std::move(from);
  }

  inline Room_Set_tankid_Response& operator=(const Room_Set_tankid_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room_Set_tankid_Response& operator=(Room_Set_tankid_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Room_Set_tankid_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room_Set_tankid_Response* internal_default_instance() {
    return reinterpret_cast<const Room_Set_tankid_Response*>(
               &_Room_Set_tankid_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(Room_Set_tankid_Response& a, Room_Set_tankid_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Room_Set_tankid_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room_Set_tankid_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room_Set_tankid_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room_Set_tankid_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Room_Set_tankid_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Room_Set_tankid_Response& from) {
    Room_Set_tankid_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Room_Set_tankid_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Room_Set_tankid_Response";
  }
  protected:
  explicit Room_Set_tankid_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Room_Set_tankid_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Room_Start_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Room_Start_Response) */ {
 public:
  inline Room_Start_Response() : Room_Start_Response(nullptr) {}
  ~Room_Start_Response() override;
  explicit PROTOBUF_CONSTEXPR Room_Start_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Room_Start_Response(const Room_Start_Response& from);
  Room_Start_Response(Room_Start_Response&& from) noexcept
    : Room_Start_Response() {
    *this = ::std::move(from);
  }

  inline Room_Start_Response& operator=(const Room_Start_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Room_Start_Response& operator=(Room_Start_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Room_Start_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Room_Start_Response* internal_default_instance() {
    return reinterpret_cast<const Room_Start_Response*>(
               &_Room_Start_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(Room_Start_Response& a, Room_Start_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Room_Start_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Room_Start_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Room_Start_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Room_Start_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Room_Start_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Room_Start_Response& from) {
    Room_Start_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Room_Start_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Room_Start_Response";
  }
  protected:
  explicit Room_Start_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // int32 result = 1;
  void clear_result();
  int32_t result() const;
  void set_result(int32_t value);
  private:
  int32_t _internal_result() const;
  void _internal_set_result(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Room_Start_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Game_tankinfo_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Game_tankinfo_Request) */ {
 public:
  inline Game_tankinfo_Request() : Game_tankinfo_Request(nullptr) {}
  ~Game_tankinfo_Request() override;
  explicit PROTOBUF_CONSTEXPR Game_tankinfo_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Game_tankinfo_Request(const Game_tankinfo_Request& from);
  Game_tankinfo_Request(Game_tankinfo_Request&& from) noexcept
    : Game_tankinfo_Request() {
    *this = ::std::move(from);
  }

  inline Game_tankinfo_Request& operator=(const Game_tankinfo_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_tankinfo_Request& operator=(Game_tankinfo_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Game_tankinfo_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_tankinfo_Request* internal_default_instance() {
    return reinterpret_cast<const Game_tankinfo_Request*>(
               &_Game_tankinfo_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Game_tankinfo_Request& a, Game_tankinfo_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_tankinfo_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_tankinfo_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_tankinfo_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_tankinfo_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Game_tankinfo_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Game_tankinfo_Request& from) {
    Game_tankinfo_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Game_tankinfo_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Game_tankinfo_Request";
  }
  protected:
  explicit Game_tankinfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationXFieldNumber = 1,
    kLocationYFieldNumber = 2,
    kRotateFieldNumber = 3,
    kTankStyleFieldNumber = 4,
  };
  // double locationX = 1;
  void clear_locationx();
  double locationx() const;
  void set_locationx(double value);
  private:
  double _internal_locationx() const;
  void _internal_set_locationx(double value);
  public:

  // double locationY = 2;
  void clear_locationy();
  double locationy() const;
  void set_locationy(double value);
  private:
  double _internal_locationy() const;
  void _internal_set_locationy(double value);
  public:

  // double rotate = 3;
  void clear_rotate();
  double rotate() const;
  void set_rotate(double value);
  private:
  double _internal_rotate() const;
  void _internal_set_rotate(double value);
  public:

  // int32 tank_style = 4;
  void clear_tank_style();
  int32_t tank_style() const;
  void set_tank_style(int32_t value);
  private:
  int32_t _internal_tank_style() const;
  void _internal_set_tank_style(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Game_tankinfo_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double locationx_;
    double locationy_;
    double rotate_;
    int32_t tank_style_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Game_tankinfo_Response_tankinfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Game_tankinfo_Response.tankinfo) */ {
 public:
  inline Game_tankinfo_Response_tankinfo() : Game_tankinfo_Response_tankinfo(nullptr) {}
  ~Game_tankinfo_Response_tankinfo() override;
  explicit PROTOBUF_CONSTEXPR Game_tankinfo_Response_tankinfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Game_tankinfo_Response_tankinfo(const Game_tankinfo_Response_tankinfo& from);
  Game_tankinfo_Response_tankinfo(Game_tankinfo_Response_tankinfo&& from) noexcept
    : Game_tankinfo_Response_tankinfo() {
    *this = ::std::move(from);
  }

  inline Game_tankinfo_Response_tankinfo& operator=(const Game_tankinfo_Response_tankinfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_tankinfo_Response_tankinfo& operator=(Game_tankinfo_Response_tankinfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Game_tankinfo_Response_tankinfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_tankinfo_Response_tankinfo* internal_default_instance() {
    return reinterpret_cast<const Game_tankinfo_Response_tankinfo*>(
               &_Game_tankinfo_Response_tankinfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(Game_tankinfo_Response_tankinfo& a, Game_tankinfo_Response_tankinfo& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_tankinfo_Response_tankinfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_tankinfo_Response_tankinfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_tankinfo_Response_tankinfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_tankinfo_Response_tankinfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Game_tankinfo_Response_tankinfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Game_tankinfo_Response_tankinfo& from) {
    Game_tankinfo_Response_tankinfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Game_tankinfo_Response_tankinfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Game_tankinfo_Response.tankinfo";
  }
  protected:
  explicit Game_tankinfo_Response_tankinfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTankinfoFieldNumber = 2,
    kIdFieldNumber = 1,
    kHealthFieldNumber = 3,
  };
  // .Message.Game_tankinfo_Request tankinfo = 2;
  bool has_tankinfo() const;
  private:
  bool _internal_has_tankinfo() const;
  public:
  void clear_tankinfo();
  const ::Message::Game_tankinfo_Request& tankinfo() const;
  PROTOBUF_NODISCARD ::Message::Game_tankinfo_Request* release_tankinfo();
  ::Message::Game_tankinfo_Request* mutable_tankinfo();
  void set_allocated_tankinfo(::Message::Game_tankinfo_Request* tankinfo);
  private:
  const ::Message::Game_tankinfo_Request& _internal_tankinfo() const;
  ::Message::Game_tankinfo_Request* _internal_mutable_tankinfo();
  public:
  void unsafe_arena_set_allocated_tankinfo(
      ::Message::Game_tankinfo_Request* tankinfo);
  ::Message::Game_tankinfo_Request* unsafe_arena_release_tankinfo();

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 health = 3;
  void clear_health();
  int32_t health() const;
  void set_health(int32_t value);
  private:
  int32_t _internal_health() const;
  void _internal_set_health(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Game_tankinfo_Response.tankinfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Message::Game_tankinfo_Request* tankinfo_;
    int32_t id_;
    int32_t health_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Game_tankinfo_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Game_tankinfo_Response) */ {
 public:
  inline Game_tankinfo_Response() : Game_tankinfo_Response(nullptr) {}
  ~Game_tankinfo_Response() override;
  explicit PROTOBUF_CONSTEXPR Game_tankinfo_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Game_tankinfo_Response(const Game_tankinfo_Response& from);
  Game_tankinfo_Response(Game_tankinfo_Response&& from) noexcept
    : Game_tankinfo_Response() {
    *this = ::std::move(from);
  }

  inline Game_tankinfo_Response& operator=(const Game_tankinfo_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_tankinfo_Response& operator=(Game_tankinfo_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Game_tankinfo_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_tankinfo_Response* internal_default_instance() {
    return reinterpret_cast<const Game_tankinfo_Response*>(
               &_Game_tankinfo_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Game_tankinfo_Response& a, Game_tankinfo_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_tankinfo_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_tankinfo_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_tankinfo_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_tankinfo_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Game_tankinfo_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Game_tankinfo_Response& from) {
    Game_tankinfo_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Game_tankinfo_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Game_tankinfo_Response";
  }
  protected:
  explicit Game_tankinfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Game_tankinfo_Response_tankinfo tankinfo;

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // repeated .Message.Game_tankinfo_Response.tankinfo info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  ::Message::Game_tankinfo_Response_tankinfo* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Game_tankinfo_Response_tankinfo >*
      mutable_info();
  private:
  const ::Message::Game_tankinfo_Response_tankinfo& _internal_info(int index) const;
  ::Message::Game_tankinfo_Response_tankinfo* _internal_add_info();
  public:
  const ::Message::Game_tankinfo_Response_tankinfo& info(int index) const;
  ::Message::Game_tankinfo_Response_tankinfo* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Game_tankinfo_Response_tankinfo >&
      info() const;

  // @@protoc_insertion_point(class_scope:Message.Game_tankinfo_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Game_tankinfo_Response_tankinfo > info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class bulletinfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.bulletinfo) */ {
 public:
  inline bulletinfo() : bulletinfo(nullptr) {}
  ~bulletinfo() override;
  explicit PROTOBUF_CONSTEXPR bulletinfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  bulletinfo(const bulletinfo& from);
  bulletinfo(bulletinfo&& from) noexcept
    : bulletinfo() {
    *this = ::std::move(from);
  }

  inline bulletinfo& operator=(const bulletinfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline bulletinfo& operator=(bulletinfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const bulletinfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const bulletinfo* internal_default_instance() {
    return reinterpret_cast<const bulletinfo*>(
               &_bulletinfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(bulletinfo& a, bulletinfo& b) {
    a.Swap(&b);
  }
  inline void Swap(bulletinfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(bulletinfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  bulletinfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<bulletinfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const bulletinfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const bulletinfo& from) {
    bulletinfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(bulletinfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.bulletinfo";
  }
  protected:
  explicit bulletinfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationXFieldNumber = 1,
    kLocationYFieldNumber = 2,
    kRotateFieldNumber = 3,
    kBulletStyleFieldNumber = 4,
  };
  // double locationX = 1;
  void clear_locationx();
  double locationx() const;
  void set_locationx(double value);
  private:
  double _internal_locationx() const;
  void _internal_set_locationx(double value);
  public:

  // double locationY = 2;
  void clear_locationy();
  double locationy() const;
  void set_locationy(double value);
  private:
  double _internal_locationy() const;
  void _internal_set_locationy(double value);
  public:

  // double rotate = 3;
  void clear_rotate();
  double rotate() const;
  void set_rotate(double value);
  private:
  double _internal_rotate() const;
  void _internal_set_rotate(double value);
  public:

  // int32 bullet_style = 4;
  void clear_bullet_style();
  int32_t bullet_style() const;
  void set_bullet_style(int32_t value);
  private:
  int32_t _internal_bullet_style() const;
  void _internal_set_bullet_style(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.bulletinfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double locationx_;
    double locationy_;
    double rotate_;
    int32_t bullet_style_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Game_bulletinfo_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Game_bulletinfo_Request) */ {
 public:
  inline Game_bulletinfo_Request() : Game_bulletinfo_Request(nullptr) {}
  ~Game_bulletinfo_Request() override;
  explicit PROTOBUF_CONSTEXPR Game_bulletinfo_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Game_bulletinfo_Request(const Game_bulletinfo_Request& from);
  Game_bulletinfo_Request(Game_bulletinfo_Request&& from) noexcept
    : Game_bulletinfo_Request() {
    *this = ::std::move(from);
  }

  inline Game_bulletinfo_Request& operator=(const Game_bulletinfo_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_bulletinfo_Request& operator=(Game_bulletinfo_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Game_bulletinfo_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_bulletinfo_Request* internal_default_instance() {
    return reinterpret_cast<const Game_bulletinfo_Request*>(
               &_Game_bulletinfo_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(Game_bulletinfo_Request& a, Game_bulletinfo_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_bulletinfo_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_bulletinfo_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_bulletinfo_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_bulletinfo_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Game_bulletinfo_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Game_bulletinfo_Request& from) {
    Game_bulletinfo_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Game_bulletinfo_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Game_bulletinfo_Request";
  }
  protected:
  explicit Game_bulletinfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBulletinfoFieldNumber = 2,
  };
  // repeated .Message.bulletinfo bulletinfo = 2;
  int bulletinfo_size() const;
  private:
  int _internal_bulletinfo_size() const;
  public:
  void clear_bulletinfo();
  ::Message::bulletinfo* mutable_bulletinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::bulletinfo >*
      mutable_bulletinfo();
  private:
  const ::Message::bulletinfo& _internal_bulletinfo(int index) const;
  ::Message::bulletinfo* _internal_add_bulletinfo();
  public:
  const ::Message::bulletinfo& bulletinfo(int index) const;
  ::Message::bulletinfo* add_bulletinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::bulletinfo >&
      bulletinfo() const;

  // @@protoc_insertion_point(class_scope:Message.Game_bulletinfo_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::bulletinfo > bulletinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Game_bulletinfo_Response_Info final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Game_bulletinfo_Response.Info) */ {
 public:
  inline Game_bulletinfo_Response_Info() : Game_bulletinfo_Response_Info(nullptr) {}
  ~Game_bulletinfo_Response_Info() override;
  explicit PROTOBUF_CONSTEXPR Game_bulletinfo_Response_Info(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Game_bulletinfo_Response_Info(const Game_bulletinfo_Response_Info& from);
  Game_bulletinfo_Response_Info(Game_bulletinfo_Response_Info&& from) noexcept
    : Game_bulletinfo_Response_Info() {
    *this = ::std::move(from);
  }

  inline Game_bulletinfo_Response_Info& operator=(const Game_bulletinfo_Response_Info& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_bulletinfo_Response_Info& operator=(Game_bulletinfo_Response_Info&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Game_bulletinfo_Response_Info& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_bulletinfo_Response_Info* internal_default_instance() {
    return reinterpret_cast<const Game_bulletinfo_Response_Info*>(
               &_Game_bulletinfo_Response_Info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Game_bulletinfo_Response_Info& a, Game_bulletinfo_Response_Info& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_bulletinfo_Response_Info* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_bulletinfo_Response_Info* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_bulletinfo_Response_Info* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_bulletinfo_Response_Info>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Game_bulletinfo_Response_Info& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Game_bulletinfo_Response_Info& from) {
    Game_bulletinfo_Response_Info::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Game_bulletinfo_Response_Info* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Game_bulletinfo_Response.Info";
  }
  protected:
  explicit Game_bulletinfo_Response_Info(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBulletinfoFieldNumber = 2,
    kTankidFieldNumber = 1,
  };
  // repeated .Message.bulletinfo bulletinfo = 2;
  int bulletinfo_size() const;
  private:
  int _internal_bulletinfo_size() const;
  public:
  void clear_bulletinfo();
  ::Message::bulletinfo* mutable_bulletinfo(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::bulletinfo >*
      mutable_bulletinfo();
  private:
  const ::Message::bulletinfo& _internal_bulletinfo(int index) const;
  ::Message::bulletinfo* _internal_add_bulletinfo();
  public:
  const ::Message::bulletinfo& bulletinfo(int index) const;
  ::Message::bulletinfo* add_bulletinfo();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::bulletinfo >&
      bulletinfo() const;

  // int32 tankid = 1;
  void clear_tankid();
  int32_t tankid() const;
  void set_tankid(int32_t value);
  private:
  int32_t _internal_tankid() const;
  void _internal_set_tankid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Game_bulletinfo_Response.Info)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::bulletinfo > bulletinfo_;
    int32_t tankid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Game_bulletinfo_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Game_bulletinfo_Response) */ {
 public:
  inline Game_bulletinfo_Response() : Game_bulletinfo_Response(nullptr) {}
  ~Game_bulletinfo_Response() override;
  explicit PROTOBUF_CONSTEXPR Game_bulletinfo_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Game_bulletinfo_Response(const Game_bulletinfo_Response& from);
  Game_bulletinfo_Response(Game_bulletinfo_Response&& from) noexcept
    : Game_bulletinfo_Response() {
    *this = ::std::move(from);
  }

  inline Game_bulletinfo_Response& operator=(const Game_bulletinfo_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_bulletinfo_Response& operator=(Game_bulletinfo_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Game_bulletinfo_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_bulletinfo_Response* internal_default_instance() {
    return reinterpret_cast<const Game_bulletinfo_Response*>(
               &_Game_bulletinfo_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Game_bulletinfo_Response& a, Game_bulletinfo_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_bulletinfo_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_bulletinfo_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_bulletinfo_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_bulletinfo_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Game_bulletinfo_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Game_bulletinfo_Response& from) {
    Game_bulletinfo_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Game_bulletinfo_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Game_bulletinfo_Response";
  }
  protected:
  explicit Game_bulletinfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Game_bulletinfo_Response_Info Info;

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // repeated .Message.Game_bulletinfo_Response.Info info = 1;
  int info_size() const;
  private:
  int _internal_info_size() const;
  public:
  void clear_info();
  ::Message::Game_bulletinfo_Response_Info* mutable_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Game_bulletinfo_Response_Info >*
      mutable_info();
  private:
  const ::Message::Game_bulletinfo_Response_Info& _internal_info(int index) const;
  ::Message::Game_bulletinfo_Response_Info* _internal_add_info();
  public:
  const ::Message::Game_bulletinfo_Response_Info& info(int index) const;
  ::Message::Game_bulletinfo_Response_Info* add_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Game_bulletinfo_Response_Info >&
      info() const;

  // @@protoc_insertion_point(class_scope:Message.Game_bulletinfo_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Game_bulletinfo_Response_Info > info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Game_hit_brick_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Game_hit_brick_Request) */ {
 public:
  inline Game_hit_brick_Request() : Game_hit_brick_Request(nullptr) {}
  ~Game_hit_brick_Request() override;
  explicit PROTOBUF_CONSTEXPR Game_hit_brick_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Game_hit_brick_Request(const Game_hit_brick_Request& from);
  Game_hit_brick_Request(Game_hit_brick_Request&& from) noexcept
    : Game_hit_brick_Request() {
    *this = ::std::move(from);
  }

  inline Game_hit_brick_Request& operator=(const Game_hit_brick_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_hit_brick_Request& operator=(Game_hit_brick_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Game_hit_brick_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_hit_brick_Request* internal_default_instance() {
    return reinterpret_cast<const Game_hit_brick_Request*>(
               &_Game_hit_brick_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Game_hit_brick_Request& a, Game_hit_brick_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_hit_brick_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_hit_brick_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_hit_brick_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_hit_brick_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Game_hit_brick_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Game_hit_brick_Request& from) {
    Game_hit_brick_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Game_hit_brick_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Game_hit_brick_Request";
  }
  protected:
  explicit Game_hit_brick_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBulletinfoFieldNumber = 2,
    kHitedBrickIdFieldNumber = 1,
  };
  // .Message.bulletinfo bulletinfo = 2;
  bool has_bulletinfo() const;
  private:
  bool _internal_has_bulletinfo() const;
  public:
  void clear_bulletinfo();
  const ::Message::bulletinfo& bulletinfo() const;
  PROTOBUF_NODISCARD ::Message::bulletinfo* release_bulletinfo();
  ::Message::bulletinfo* mutable_bulletinfo();
  void set_allocated_bulletinfo(::Message::bulletinfo* bulletinfo);
  private:
  const ::Message::bulletinfo& _internal_bulletinfo() const;
  ::Message::bulletinfo* _internal_mutable_bulletinfo();
  public:
  void unsafe_arena_set_allocated_bulletinfo(
      ::Message::bulletinfo* bulletinfo);
  ::Message::bulletinfo* unsafe_arena_release_bulletinfo();

  // int32 hited_brick_id = 1;
  void clear_hited_brick_id();
  int32_t hited_brick_id() const;
  void set_hited_brick_id(int32_t value);
  private:
  int32_t _internal_hited_brick_id() const;
  void _internal_set_hited_brick_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Game_hit_brick_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Message::bulletinfo* bulletinfo_;
    int32_t hited_brick_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Game_brick_hited_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Game_brick_hited_Response) */ {
 public:
  inline Game_brick_hited_Response() : Game_brick_hited_Response(nullptr) {}
  ~Game_brick_hited_Response() override;
  explicit PROTOBUF_CONSTEXPR Game_brick_hited_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Game_brick_hited_Response(const Game_brick_hited_Response& from);
  Game_brick_hited_Response(Game_brick_hited_Response&& from) noexcept
    : Game_brick_hited_Response() {
    *this = ::std::move(from);
  }

  inline Game_brick_hited_Response& operator=(const Game_brick_hited_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_brick_hited_Response& operator=(Game_brick_hited_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Game_brick_hited_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_brick_hited_Response* internal_default_instance() {
    return reinterpret_cast<const Game_brick_hited_Response*>(
               &_Game_brick_hited_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(Game_brick_hited_Response& a, Game_brick_hited_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_brick_hited_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_brick_hited_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_brick_hited_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_brick_hited_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Game_brick_hited_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Game_brick_hited_Response& from) {
    Game_brick_hited_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Game_brick_hited_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Game_brick_hited_Response";
  }
  protected:
  explicit Game_brick_hited_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHitedBrickIdFieldNumber = 1,
    kHealthFieldNumber = 2,
  };
  // int32 hited_brick_id = 1;
  void clear_hited_brick_id();
  int32_t hited_brick_id() const;
  void set_hited_brick_id(int32_t value);
  private:
  int32_t _internal_hited_brick_id() const;
  void _internal_set_hited_brick_id(int32_t value);
  public:

  // int32 health = 2;
  void clear_health();
  int32_t health() const;
  void set_health(int32_t value);
  private:
  int32_t _internal_health() const;
  void _internal_set_health(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Game_brick_hited_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t hited_brick_id_;
    int32_t health_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Game_hit_tank_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Game_hit_tank_Request) */ {
 public:
  inline Game_hit_tank_Request() : Game_hit_tank_Request(nullptr) {}
  ~Game_hit_tank_Request() override;
  explicit PROTOBUF_CONSTEXPR Game_hit_tank_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Game_hit_tank_Request(const Game_hit_tank_Request& from);
  Game_hit_tank_Request(Game_hit_tank_Request&& from) noexcept
    : Game_hit_tank_Request() {
    *this = ::std::move(from);
  }

  inline Game_hit_tank_Request& operator=(const Game_hit_tank_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_hit_tank_Request& operator=(Game_hit_tank_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Game_hit_tank_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_hit_tank_Request* internal_default_instance() {
    return reinterpret_cast<const Game_hit_tank_Request*>(
               &_Game_hit_tank_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(Game_hit_tank_Request& a, Game_hit_tank_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_hit_tank_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_hit_tank_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_hit_tank_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_hit_tank_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Game_hit_tank_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Game_hit_tank_Request& from) {
    Game_hit_tank_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Game_hit_tank_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Game_hit_tank_Request";
  }
  protected:
  explicit Game_hit_tank_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBulletinfoFieldNumber = 2,
    kHitedTankIdFieldNumber = 1,
  };
  // .Message.bulletinfo bulletinfo = 2;
  bool has_bulletinfo() const;
  private:
  bool _internal_has_bulletinfo() const;
  public:
  void clear_bulletinfo();
  const ::Message::bulletinfo& bulletinfo() const;
  PROTOBUF_NODISCARD ::Message::bulletinfo* release_bulletinfo();
  ::Message::bulletinfo* mutable_bulletinfo();
  void set_allocated_bulletinfo(::Message::bulletinfo* bulletinfo);
  private:
  const ::Message::bulletinfo& _internal_bulletinfo() const;
  ::Message::bulletinfo* _internal_mutable_bulletinfo();
  public:
  void unsafe_arena_set_allocated_bulletinfo(
      ::Message::bulletinfo* bulletinfo);
  ::Message::bulletinfo* unsafe_arena_release_bulletinfo();

  // int32 hited_tank_id = 1;
  void clear_hited_tank_id();
  int32_t hited_tank_id() const;
  void set_hited_tank_id(int32_t value);
  private:
  int32_t _internal_hited_tank_id() const;
  void _internal_set_hited_tank_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Game_hit_tank_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Message::bulletinfo* bulletinfo_;
    int32_t hited_tank_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Game_tank_hited_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Game_tank_hited_Response) */ {
 public:
  inline Game_tank_hited_Response() : Game_tank_hited_Response(nullptr) {}
  ~Game_tank_hited_Response() override;
  explicit PROTOBUF_CONSTEXPR Game_tank_hited_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Game_tank_hited_Response(const Game_tank_hited_Response& from);
  Game_tank_hited_Response(Game_tank_hited_Response&& from) noexcept
    : Game_tank_hited_Response() {
    *this = ::std::move(from);
  }

  inline Game_tank_hited_Response& operator=(const Game_tank_hited_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_tank_hited_Response& operator=(Game_tank_hited_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Game_tank_hited_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_tank_hited_Response* internal_default_instance() {
    return reinterpret_cast<const Game_tank_hited_Response*>(
               &_Game_tank_hited_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Game_tank_hited_Response& a, Game_tank_hited_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_tank_hited_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_tank_hited_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_tank_hited_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_tank_hited_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Game_tank_hited_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Game_tank_hited_Response& from) {
    Game_tank_hited_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Game_tank_hited_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Game_tank_hited_Response";
  }
  protected:
  explicit Game_tank_hited_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHitedTankIdFieldNumber = 1,
    kHealthFieldNumber = 2,
  };
  // int32 hited_tank_id = 1;
  void clear_hited_tank_id();
  int32_t hited_tank_id() const;
  void set_hited_tank_id(int32_t value);
  private:
  int32_t _internal_hited_tank_id() const;
  void _internal_set_hited_tank_id(int32_t value);
  public:

  // int32 health = 2;
  void clear_health();
  int32_t health() const;
  void set_health(int32_t value);
  private:
  int32_t _internal_health() const;
  void _internal_set_health(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Game_tank_hited_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t hited_tank_id_;
    int32_t health_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Game_destroyed_tank_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Game_destroyed_tank_Response) */ {
 public:
  inline Game_destroyed_tank_Response() : Game_destroyed_tank_Response(nullptr) {}
  ~Game_destroyed_tank_Response() override;
  explicit PROTOBUF_CONSTEXPR Game_destroyed_tank_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Game_destroyed_tank_Response(const Game_destroyed_tank_Response& from);
  Game_destroyed_tank_Response(Game_destroyed_tank_Response&& from) noexcept
    : Game_destroyed_tank_Response() {
    *this = ::std::move(from);
  }

  inline Game_destroyed_tank_Response& operator=(const Game_destroyed_tank_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_destroyed_tank_Response& operator=(Game_destroyed_tank_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Game_destroyed_tank_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_destroyed_tank_Response* internal_default_instance() {
    return reinterpret_cast<const Game_destroyed_tank_Response*>(
               &_Game_destroyed_tank_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(Game_destroyed_tank_Response& a, Game_destroyed_tank_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_destroyed_tank_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_destroyed_tank_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_destroyed_tank_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_destroyed_tank_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Game_destroyed_tank_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Game_destroyed_tank_Response& from) {
    Game_destroyed_tank_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Game_destroyed_tank_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Game_destroyed_tank_Response";
  }
  protected:
  explicit Game_destroyed_tank_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestroyedTankIdFieldNumber = 1,
  };
  // int32 destroyed_tank_id = 1;
  void clear_destroyed_tank_id();
  int32_t destroyed_tank_id() const;
  void set_destroyed_tank_id(int32_t value);
  private:
  int32_t _internal_destroyed_tank_id() const;
  void _internal_set_destroyed_tank_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Game_destroyed_tank_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t destroyed_tank_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Game_create_prop final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Game_create_prop) */ {
 public:
  inline Game_create_prop() : Game_create_prop(nullptr) {}
  ~Game_create_prop() override;
  explicit PROTOBUF_CONSTEXPR Game_create_prop(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Game_create_prop(const Game_create_prop& from);
  Game_create_prop(Game_create_prop&& from) noexcept
    : Game_create_prop() {
    *this = ::std::move(from);
  }

  inline Game_create_prop& operator=(const Game_create_prop& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_create_prop& operator=(Game_create_prop&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Game_create_prop& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_create_prop* internal_default_instance() {
    return reinterpret_cast<const Game_create_prop*>(
               &_Game_create_prop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(Game_create_prop& a, Game_create_prop& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_create_prop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_create_prop* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_create_prop* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_create_prop>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Game_create_prop& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Game_create_prop& from) {
    Game_create_prop::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Game_create_prop* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Game_create_prop";
  }
  protected:
  explicit Game_create_prop(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationXFieldNumber = 2,
    kLocationYFieldNumber = 3,
    kPropTypeFieldNumber = 1,
  };
  // double locationX = 2;
  void clear_locationx();
  double locationx() const;
  void set_locationx(double value);
  private:
  double _internal_locationx() const;
  void _internal_set_locationx(double value);
  public:

  // double locationY = 3;
  void clear_locationy();
  double locationy() const;
  void set_locationy(double value);
  private:
  double _internal_locationy() const;
  void _internal_set_locationy(double value);
  public:

  // int32 prop_type = 1;
  void clear_prop_type();
  int32_t prop_type() const;
  void set_prop_type(int32_t value);
  private:
  int32_t _internal_prop_type() const;
  void _internal_set_prop_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Game_create_prop)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double locationx_;
    double locationy_;
    int32_t prop_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Game_getProp_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Game_getProp_Request) */ {
 public:
  inline Game_getProp_Request() : Game_getProp_Request(nullptr) {}
  ~Game_getProp_Request() override;
  explicit PROTOBUF_CONSTEXPR Game_getProp_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Game_getProp_Request(const Game_getProp_Request& from);
  Game_getProp_Request(Game_getProp_Request&& from) noexcept
    : Game_getProp_Request() {
    *this = ::std::move(from);
  }

  inline Game_getProp_Request& operator=(const Game_getProp_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_getProp_Request& operator=(Game_getProp_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Game_getProp_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_getProp_Request* internal_default_instance() {
    return reinterpret_cast<const Game_getProp_Request*>(
               &_Game_getProp_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Game_getProp_Request& a, Game_getProp_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_getProp_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_getProp_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_getProp_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_getProp_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Game_getProp_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Game_getProp_Request& from) {
    Game_getProp_Request::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Game_getProp_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Game_getProp_Request";
  }
  protected:
  explicit Game_getProp_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropIdFieldNumber = 1,
  };
  // int32 prop_id = 1;
  void clear_prop_id();
  int32_t prop_id() const;
  void set_prop_id(int32_t value);
  private:
  int32_t _internal_prop_id() const;
  void _internal_set_prop_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Game_getProp_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t prop_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class Game_prop_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.Game_prop_Response) */ {
 public:
  inline Game_prop_Response() : Game_prop_Response(nullptr) {}
  ~Game_prop_Response() override;
  explicit PROTOBUF_CONSTEXPR Game_prop_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Game_prop_Response(const Game_prop_Response& from);
  Game_prop_Response(Game_prop_Response&& from) noexcept
    : Game_prop_Response() {
    *this = ::std::move(from);
  }

  inline Game_prop_Response& operator=(const Game_prop_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Game_prop_Response& operator=(Game_prop_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Game_prop_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Game_prop_Response* internal_default_instance() {
    return reinterpret_cast<const Game_prop_Response*>(
               &_Game_prop_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Game_prop_Response& a, Game_prop_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Game_prop_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Game_prop_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Game_prop_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Game_prop_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Game_prop_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Game_prop_Response& from) {
    Game_prop_Response::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Game_prop_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.Game_prop_Response";
  }
  protected:
  explicit Game_prop_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPropIdFieldNumber = 1,
    kTankIdFieldNumber = 2,
  };
  // int32 prop_id = 1;
  void clear_prop_id();
  int32_t prop_id() const;
  void set_prop_id(int32_t value);
  private:
  int32_t _internal_prop_id() const;
  void _internal_set_prop_id(int32_t value);
  public:

  // int32 tank_id = 2;
  void clear_tank_id();
  int32_t tank_id() const;
  void set_tank_id(int32_t value);
  private:
  int32_t _internal_tank_id() const;
  void _internal_set_tank_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.Game_prop_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t prop_id_;
    int32_t tank_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class UDP_INFO_REQ final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.UDP_INFO_REQ) */ {
 public:
  inline UDP_INFO_REQ() : UDP_INFO_REQ(nullptr) {}
  ~UDP_INFO_REQ() override;
  explicit PROTOBUF_CONSTEXPR UDP_INFO_REQ(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UDP_INFO_REQ(const UDP_INFO_REQ& from);
  UDP_INFO_REQ(UDP_INFO_REQ&& from) noexcept
    : UDP_INFO_REQ() {
    *this = ::std::move(from);
  }

  inline UDP_INFO_REQ& operator=(const UDP_INFO_REQ& from) {
    CopyFrom(from);
    return *this;
  }
  inline UDP_INFO_REQ& operator=(UDP_INFO_REQ&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UDP_INFO_REQ& default_instance() {
    return *internal_default_instance();
  }
  static inline const UDP_INFO_REQ* internal_default_instance() {
    return reinterpret_cast<const UDP_INFO_REQ*>(
               &_UDP_INFO_REQ_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(UDP_INFO_REQ& a, UDP_INFO_REQ& b) {
    a.Swap(&b);
  }
  inline void Swap(UDP_INFO_REQ* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UDP_INFO_REQ* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UDP_INFO_REQ* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UDP_INFO_REQ>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UDP_INFO_REQ& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UDP_INFO_REQ& from) {
    UDP_INFO_REQ::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UDP_INFO_REQ* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.UDP_INFO_REQ";
  }
  protected:
  explicit UDP_INFO_REQ(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // int32 port = 2;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Message.UDP_INFO_REQ)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
    int32_t port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// -------------------------------------------------------------------

class UDP_INFO_RES final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Message.UDP_INFO_RES) */ {
 public:
  inline UDP_INFO_RES() : UDP_INFO_RES(nullptr) {}
  ~UDP_INFO_RES() override;
  explicit PROTOBUF_CONSTEXPR UDP_INFO_RES(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UDP_INFO_RES(const UDP_INFO_RES& from);
  UDP_INFO_RES(UDP_INFO_RES&& from) noexcept
    : UDP_INFO_RES() {
    *this = ::std::move(from);
  }

  inline UDP_INFO_RES& operator=(const UDP_INFO_RES& from) {
    CopyFrom(from);
    return *this;
  }
  inline UDP_INFO_RES& operator=(UDP_INFO_RES&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const UDP_INFO_RES& default_instance() {
    return *internal_default_instance();
  }
  static inline const UDP_INFO_RES* internal_default_instance() {
    return reinterpret_cast<const UDP_INFO_RES*>(
               &_UDP_INFO_RES_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(UDP_INFO_RES& a, UDP_INFO_RES& b) {
    a.Swap(&b);
  }
  inline void Swap(UDP_INFO_RES* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UDP_INFO_RES* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UDP_INFO_RES* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UDP_INFO_RES>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const UDP_INFO_RES& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const UDP_INFO_RES& from) {
    UDP_INFO_RES::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UDP_INFO_RES* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Message.UDP_INFO_RES";
  }
  protected:
  explicit UDP_INFO_RES(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOKFieldNumber = 1,
  };
  // bool OK = 1;
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Message.UDP_INFO_RES)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool ok_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_myprotocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Hall_info_Response_User

// string name = 1;
inline void Hall_info_Response_User::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Hall_info_Response_User::name() const {
  // @@protoc_insertion_point(field_get:Message.Hall_info_Response.User.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hall_info_Response_User::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Message.Hall_info_Response.User.name)
}
inline std::string* Hall_info_Response_User::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Message.Hall_info_Response.User.name)
  return _s;
}
inline const std::string& Hall_info_Response_User::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Hall_info_Response_User::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Hall_info_Response_User::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Hall_info_Response_User::release_name() {
  // @@protoc_insertion_point(field_release:Message.Hall_info_Response.User.name)
  return _impl_.name_.Release();
}
inline void Hall_info_Response_User::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Hall_info_Response.User.name)
}

// -------------------------------------------------------------------

// Hall_info_Response_Roominfo

// int32 room_id = 1;
inline void Hall_info_Response_Roominfo::clear_room_id() {
  _impl_.room_id_ = 0;
}
inline int32_t Hall_info_Response_Roominfo::_internal_room_id() const {
  return _impl_.room_id_;
}
inline int32_t Hall_info_Response_Roominfo::room_id() const {
  // @@protoc_insertion_point(field_get:Message.Hall_info_Response.Roominfo.room_id)
  return _internal_room_id();
}
inline void Hall_info_Response_Roominfo::_internal_set_room_id(int32_t value) {
  
  _impl_.room_id_ = value;
}
inline void Hall_info_Response_Roominfo::set_room_id(int32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:Message.Hall_info_Response.Roominfo.room_id)
}

// string host_name = 2;
inline void Hall_info_Response_Roominfo::clear_host_name() {
  _impl_.host_name_.ClearToEmpty();
}
inline const std::string& Hall_info_Response_Roominfo::host_name() const {
  // @@protoc_insertion_point(field_get:Message.Hall_info_Response.Roominfo.host_name)
  return _internal_host_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hall_info_Response_Roominfo::set_host_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.host_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Message.Hall_info_Response.Roominfo.host_name)
}
inline std::string* Hall_info_Response_Roominfo::mutable_host_name() {
  std::string* _s = _internal_mutable_host_name();
  // @@protoc_insertion_point(field_mutable:Message.Hall_info_Response.Roominfo.host_name)
  return _s;
}
inline const std::string& Hall_info_Response_Roominfo::_internal_host_name() const {
  return _impl_.host_name_.Get();
}
inline void Hall_info_Response_Roominfo::_internal_set_host_name(const std::string& value) {
  
  _impl_.host_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Hall_info_Response_Roominfo::_internal_mutable_host_name() {
  
  return _impl_.host_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Hall_info_Response_Roominfo::release_host_name() {
  // @@protoc_insertion_point(field_release:Message.Hall_info_Response.Roominfo.host_name)
  return _impl_.host_name_.Release();
}
inline void Hall_info_Response_Roominfo::set_allocated_host_name(std::string* host_name) {
  if (host_name != nullptr) {
    
  } else {
    
  }
  _impl_.host_name_.SetAllocated(host_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.host_name_.IsDefault()) {
    _impl_.host_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Hall_info_Response.Roominfo.host_name)
}

// -------------------------------------------------------------------

// Hall_info_Response

// repeated .Message.Hall_info_Response.User userinfo = 1;
inline int Hall_info_Response::_internal_userinfo_size() const {
  return _impl_.userinfo_.size();
}
inline int Hall_info_Response::userinfo_size() const {
  return _internal_userinfo_size();
}
inline void Hall_info_Response::clear_userinfo() {
  _impl_.userinfo_.Clear();
}
inline ::Message::Hall_info_Response_User* Hall_info_Response::mutable_userinfo(int index) {
  // @@protoc_insertion_point(field_mutable:Message.Hall_info_Response.userinfo)
  return _impl_.userinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Hall_info_Response_User >*
Hall_info_Response::mutable_userinfo() {
  // @@protoc_insertion_point(field_mutable_list:Message.Hall_info_Response.userinfo)
  return &_impl_.userinfo_;
}
inline const ::Message::Hall_info_Response_User& Hall_info_Response::_internal_userinfo(int index) const {
  return _impl_.userinfo_.Get(index);
}
inline const ::Message::Hall_info_Response_User& Hall_info_Response::userinfo(int index) const {
  // @@protoc_insertion_point(field_get:Message.Hall_info_Response.userinfo)
  return _internal_userinfo(index);
}
inline ::Message::Hall_info_Response_User* Hall_info_Response::_internal_add_userinfo() {
  return _impl_.userinfo_.Add();
}
inline ::Message::Hall_info_Response_User* Hall_info_Response::add_userinfo() {
  ::Message::Hall_info_Response_User* _add = _internal_add_userinfo();
  // @@protoc_insertion_point(field_add:Message.Hall_info_Response.userinfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Hall_info_Response_User >&
Hall_info_Response::userinfo() const {
  // @@protoc_insertion_point(field_list:Message.Hall_info_Response.userinfo)
  return _impl_.userinfo_;
}

// repeated .Message.Hall_info_Response.Roominfo roominfo = 2;
inline int Hall_info_Response::_internal_roominfo_size() const {
  return _impl_.roominfo_.size();
}
inline int Hall_info_Response::roominfo_size() const {
  return _internal_roominfo_size();
}
inline void Hall_info_Response::clear_roominfo() {
  _impl_.roominfo_.Clear();
}
inline ::Message::Hall_info_Response_Roominfo* Hall_info_Response::mutable_roominfo(int index) {
  // @@protoc_insertion_point(field_mutable:Message.Hall_info_Response.roominfo)
  return _impl_.roominfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Hall_info_Response_Roominfo >*
Hall_info_Response::mutable_roominfo() {
  // @@protoc_insertion_point(field_mutable_list:Message.Hall_info_Response.roominfo)
  return &_impl_.roominfo_;
}
inline const ::Message::Hall_info_Response_Roominfo& Hall_info_Response::_internal_roominfo(int index) const {
  return _impl_.roominfo_.Get(index);
}
inline const ::Message::Hall_info_Response_Roominfo& Hall_info_Response::roominfo(int index) const {
  // @@protoc_insertion_point(field_get:Message.Hall_info_Response.roominfo)
  return _internal_roominfo(index);
}
inline ::Message::Hall_info_Response_Roominfo* Hall_info_Response::_internal_add_roominfo() {
  return _impl_.roominfo_.Add();
}
inline ::Message::Hall_info_Response_Roominfo* Hall_info_Response::add_roominfo() {
  ::Message::Hall_info_Response_Roominfo* _add = _internal_add_roominfo();
  // @@protoc_insertion_point(field_add:Message.Hall_info_Response.roominfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Hall_info_Response_Roominfo >&
Hall_info_Response::roominfo() const {
  // @@protoc_insertion_point(field_list:Message.Hall_info_Response.roominfo)
  return _impl_.roominfo_;
}

// -------------------------------------------------------------------

// Hall_Message_Request

// string content = 1;
inline void Hall_Message_Request::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Hall_Message_Request::content() const {
  // @@protoc_insertion_point(field_get:Message.Hall_Message_Request.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hall_Message_Request::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Message.Hall_Message_Request.content)
}
inline std::string* Hall_Message_Request::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:Message.Hall_Message_Request.content)
  return _s;
}
inline const std::string& Hall_Message_Request::_internal_content() const {
  return _impl_.content_.Get();
}
inline void Hall_Message_Request::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* Hall_Message_Request::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* Hall_Message_Request::release_content() {
  // @@protoc_insertion_point(field_release:Message.Hall_Message_Request.content)
  return _impl_.content_.Release();
}
inline void Hall_Message_Request::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Hall_Message_Request.content)
}

// -------------------------------------------------------------------

// Hall_Message_Response

// string name = 1;
inline void Hall_Message_Response::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Hall_Message_Response::name() const {
  // @@protoc_insertion_point(field_get:Message.Hall_Message_Response.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hall_Message_Response::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Message.Hall_Message_Response.name)
}
inline std::string* Hall_Message_Response::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Message.Hall_Message_Response.name)
  return _s;
}
inline const std::string& Hall_Message_Response::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Hall_Message_Response::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Hall_Message_Response::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Hall_Message_Response::release_name() {
  // @@protoc_insertion_point(field_release:Message.Hall_Message_Response.name)
  return _impl_.name_.Release();
}
inline void Hall_Message_Response::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Hall_Message_Response.name)
}

// string content = 2;
inline void Hall_Message_Response::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Hall_Message_Response::content() const {
  // @@protoc_insertion_point(field_get:Message.Hall_Message_Response.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Hall_Message_Response::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Message.Hall_Message_Response.content)
}
inline std::string* Hall_Message_Response::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:Message.Hall_Message_Response.content)
  return _s;
}
inline const std::string& Hall_Message_Response::_internal_content() const {
  return _impl_.content_.Get();
}
inline void Hall_Message_Response::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* Hall_Message_Response::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* Hall_Message_Response::release_content() {
  // @@protoc_insertion_point(field_release:Message.Hall_Message_Response.content)
  return _impl_.content_.Release();
}
inline void Hall_Message_Response::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Hall_Message_Response.content)
}

// -------------------------------------------------------------------

// Hall_EnterRoom_Request

// int32 room_id = 1;
inline void Hall_EnterRoom_Request::clear_room_id() {
  _impl_.room_id_ = 0;
}
inline int32_t Hall_EnterRoom_Request::_internal_room_id() const {
  return _impl_.room_id_;
}
inline int32_t Hall_EnterRoom_Request::room_id() const {
  // @@protoc_insertion_point(field_get:Message.Hall_EnterRoom_Request.room_id)
  return _internal_room_id();
}
inline void Hall_EnterRoom_Request::_internal_set_room_id(int32_t value) {
  
  _impl_.room_id_ = value;
}
inline void Hall_EnterRoom_Request::set_room_id(int32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:Message.Hall_EnterRoom_Request.room_id)
}

// -------------------------------------------------------------------

// Hall_EnterRoom_Response

// int32 room_id = 1;
inline void Hall_EnterRoom_Response::clear_room_id() {
  _impl_.room_id_ = 0;
}
inline int32_t Hall_EnterRoom_Response::_internal_room_id() const {
  return _impl_.room_id_;
}
inline int32_t Hall_EnterRoom_Response::room_id() const {
  // @@protoc_insertion_point(field_get:Message.Hall_EnterRoom_Response.room_id)
  return _internal_room_id();
}
inline void Hall_EnterRoom_Response::_internal_set_room_id(int32_t value) {
  
  _impl_.room_id_ = value;
}
inline void Hall_EnterRoom_Response::set_room_id(int32_t value) {
  _internal_set_room_id(value);
  // @@protoc_insertion_point(field_set:Message.Hall_EnterRoom_Response.room_id)
}

// int32 result = 2;
inline void Hall_EnterRoom_Response::clear_result() {
  _impl_.result_ = 0;
}
inline int32_t Hall_EnterRoom_Response::_internal_result() const {
  return _impl_.result_;
}
inline int32_t Hall_EnterRoom_Response::result() const {
  // @@protoc_insertion_point(field_get:Message.Hall_EnterRoom_Response.result)
  return _internal_result();
}
inline void Hall_EnterRoom_Response::_internal_set_result(int32_t value) {
  
  _impl_.result_ = value;
}
inline void Hall_EnterRoom_Response::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Message.Hall_EnterRoom_Response.result)
}

// -------------------------------------------------------------------

// Ping_info

// int32 ping_id = 1;
inline void Ping_info::clear_ping_id() {
  _impl_.ping_id_ = 0;
}
inline int32_t Ping_info::_internal_ping_id() const {
  return _impl_.ping_id_;
}
inline int32_t Ping_info::ping_id() const {
  // @@protoc_insertion_point(field_get:Message.Ping_info.ping_id)
  return _internal_ping_id();
}
inline void Ping_info::_internal_set_ping_id(int32_t value) {
  
  _impl_.ping_id_ = value;
}
inline void Ping_info::set_ping_id(int32_t value) {
  _internal_set_ping_id(value);
  // @@protoc_insertion_point(field_set:Message.Ping_info.ping_id)
}

// -------------------------------------------------------------------

// Set_User_id

// string name = 1;
inline void Set_User_id::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Set_User_id::name() const {
  // @@protoc_insertion_point(field_get:Message.Set_User_id.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Set_User_id::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Message.Set_User_id.name)
}
inline std::string* Set_User_id::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Message.Set_User_id.name)
  return _s;
}
inline const std::string& Set_User_id::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Set_User_id::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Set_User_id::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Set_User_id::release_name() {
  // @@protoc_insertion_point(field_release:Message.Set_User_id.name)
  return _impl_.name_.Release();
}
inline void Set_User_id::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Set_User_id.name)
}

// -------------------------------------------------------------------

// Room_info_Response_User

// string name = 1;
inline void Room_info_Response_User::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Room_info_Response_User::name() const {
  // @@protoc_insertion_point(field_get:Message.Room_info_Response.User.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Room_info_Response_User::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Message.Room_info_Response.User.name)
}
inline std::string* Room_info_Response_User::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Message.Room_info_Response.User.name)
  return _s;
}
inline const std::string& Room_info_Response_User::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Room_info_Response_User::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Room_info_Response_User::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Room_info_Response_User::release_name() {
  // @@protoc_insertion_point(field_release:Message.Room_info_Response.User.name)
  return _impl_.name_.Release();
}
inline void Room_info_Response_User::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Room_info_Response.User.name)
}

// int32 status = 2;
inline void Room_info_Response_User::clear_status() {
  _impl_.status_ = 0;
}
inline int32_t Room_info_Response_User::_internal_status() const {
  return _impl_.status_;
}
inline int32_t Room_info_Response_User::status() const {
  // @@protoc_insertion_point(field_get:Message.Room_info_Response.User.status)
  return _internal_status();
}
inline void Room_info_Response_User::_internal_set_status(int32_t value) {
  
  _impl_.status_ = value;
}
inline void Room_info_Response_User::set_status(int32_t value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:Message.Room_info_Response.User.status)
}

// -------------------------------------------------------------------

// Room_info_Response

// repeated .Message.Room_info_Response.User userinfo = 1;
inline int Room_info_Response::_internal_userinfo_size() const {
  return _impl_.userinfo_.size();
}
inline int Room_info_Response::userinfo_size() const {
  return _internal_userinfo_size();
}
inline void Room_info_Response::clear_userinfo() {
  _impl_.userinfo_.Clear();
}
inline ::Message::Room_info_Response_User* Room_info_Response::mutable_userinfo(int index) {
  // @@protoc_insertion_point(field_mutable:Message.Room_info_Response.userinfo)
  return _impl_.userinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Room_info_Response_User >*
Room_info_Response::mutable_userinfo() {
  // @@protoc_insertion_point(field_mutable_list:Message.Room_info_Response.userinfo)
  return &_impl_.userinfo_;
}
inline const ::Message::Room_info_Response_User& Room_info_Response::_internal_userinfo(int index) const {
  return _impl_.userinfo_.Get(index);
}
inline const ::Message::Room_info_Response_User& Room_info_Response::userinfo(int index) const {
  // @@protoc_insertion_point(field_get:Message.Room_info_Response.userinfo)
  return _internal_userinfo(index);
}
inline ::Message::Room_info_Response_User* Room_info_Response::_internal_add_userinfo() {
  return _impl_.userinfo_.Add();
}
inline ::Message::Room_info_Response_User* Room_info_Response::add_userinfo() {
  ::Message::Room_info_Response_User* _add = _internal_add_userinfo();
  // @@protoc_insertion_point(field_add:Message.Room_info_Response.userinfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Room_info_Response_User >&
Room_info_Response::userinfo() const {
  // @@protoc_insertion_point(field_list:Message.Room_info_Response.userinfo)
  return _impl_.userinfo_;
}

// -------------------------------------------------------------------

// Room_Message_Request

// string content = 1;
inline void Room_Message_Request::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Room_Message_Request::content() const {
  // @@protoc_insertion_point(field_get:Message.Room_Message_Request.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Room_Message_Request::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Message.Room_Message_Request.content)
}
inline std::string* Room_Message_Request::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:Message.Room_Message_Request.content)
  return _s;
}
inline const std::string& Room_Message_Request::_internal_content() const {
  return _impl_.content_.Get();
}
inline void Room_Message_Request::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* Room_Message_Request::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* Room_Message_Request::release_content() {
  // @@protoc_insertion_point(field_release:Message.Room_Message_Request.content)
  return _impl_.content_.Release();
}
inline void Room_Message_Request::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Room_Message_Request.content)
}

// -------------------------------------------------------------------

// Room_Message_Response

// string name = 1;
inline void Room_Message_Response::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& Room_Message_Response::name() const {
  // @@protoc_insertion_point(field_get:Message.Room_Message_Response.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Room_Message_Response::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Message.Room_Message_Response.name)
}
inline std::string* Room_Message_Response::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Message.Room_Message_Response.name)
  return _s;
}
inline const std::string& Room_Message_Response::_internal_name() const {
  return _impl_.name_.Get();
}
inline void Room_Message_Response::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* Room_Message_Response::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* Room_Message_Response::release_name() {
  // @@protoc_insertion_point(field_release:Message.Room_Message_Response.name)
  return _impl_.name_.Release();
}
inline void Room_Message_Response::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Room_Message_Response.name)
}

// string content = 2;
inline void Room_Message_Response::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Room_Message_Response::content() const {
  // @@protoc_insertion_point(field_get:Message.Room_Message_Response.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Room_Message_Response::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Message.Room_Message_Response.content)
}
inline std::string* Room_Message_Response::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:Message.Room_Message_Response.content)
  return _s;
}
inline const std::string& Room_Message_Response::_internal_content() const {
  return _impl_.content_.Get();
}
inline void Room_Message_Response::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* Room_Message_Response::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* Room_Message_Response::release_content() {
  // @@protoc_insertion_point(field_release:Message.Room_Message_Response.content)
  return _impl_.content_.Release();
}
inline void Room_Message_Response::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.Room_Message_Response.content)
}

// -------------------------------------------------------------------

// Room_Set_tankid

// int32 id = 1;
inline void Room_Set_tankid::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Room_Set_tankid::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Room_Set_tankid::id() const {
  // @@protoc_insertion_point(field_get:Message.Room_Set_tankid.id)
  return _internal_id();
}
inline void Room_Set_tankid::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Room_Set_tankid::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Message.Room_Set_tankid.id)
}

// -------------------------------------------------------------------

// Room_Set_tankid_Response

// int32 id = 1;
inline void Room_Set_tankid_Response::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Room_Set_tankid_Response::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Room_Set_tankid_Response::id() const {
  // @@protoc_insertion_point(field_get:Message.Room_Set_tankid_Response.id)
  return _internal_id();
}
inline void Room_Set_tankid_Response::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Room_Set_tankid_Response::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Message.Room_Set_tankid_Response.id)
}

// -------------------------------------------------------------------

// Room_Start_Response

// int32 result = 1;
inline void Room_Start_Response::clear_result() {
  _impl_.result_ = 0;
}
inline int32_t Room_Start_Response::_internal_result() const {
  return _impl_.result_;
}
inline int32_t Room_Start_Response::result() const {
  // @@protoc_insertion_point(field_get:Message.Room_Start_Response.result)
  return _internal_result();
}
inline void Room_Start_Response::_internal_set_result(int32_t value) {
  
  _impl_.result_ = value;
}
inline void Room_Start_Response::set_result(int32_t value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:Message.Room_Start_Response.result)
}

// -------------------------------------------------------------------

// Game_tankinfo_Request

// double locationX = 1;
inline void Game_tankinfo_Request::clear_locationx() {
  _impl_.locationx_ = 0;
}
inline double Game_tankinfo_Request::_internal_locationx() const {
  return _impl_.locationx_;
}
inline double Game_tankinfo_Request::locationx() const {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Request.locationX)
  return _internal_locationx();
}
inline void Game_tankinfo_Request::_internal_set_locationx(double value) {
  
  _impl_.locationx_ = value;
}
inline void Game_tankinfo_Request::set_locationx(double value) {
  _internal_set_locationx(value);
  // @@protoc_insertion_point(field_set:Message.Game_tankinfo_Request.locationX)
}

// double locationY = 2;
inline void Game_tankinfo_Request::clear_locationy() {
  _impl_.locationy_ = 0;
}
inline double Game_tankinfo_Request::_internal_locationy() const {
  return _impl_.locationy_;
}
inline double Game_tankinfo_Request::locationy() const {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Request.locationY)
  return _internal_locationy();
}
inline void Game_tankinfo_Request::_internal_set_locationy(double value) {
  
  _impl_.locationy_ = value;
}
inline void Game_tankinfo_Request::set_locationy(double value) {
  _internal_set_locationy(value);
  // @@protoc_insertion_point(field_set:Message.Game_tankinfo_Request.locationY)
}

// double rotate = 3;
inline void Game_tankinfo_Request::clear_rotate() {
  _impl_.rotate_ = 0;
}
inline double Game_tankinfo_Request::_internal_rotate() const {
  return _impl_.rotate_;
}
inline double Game_tankinfo_Request::rotate() const {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Request.rotate)
  return _internal_rotate();
}
inline void Game_tankinfo_Request::_internal_set_rotate(double value) {
  
  _impl_.rotate_ = value;
}
inline void Game_tankinfo_Request::set_rotate(double value) {
  _internal_set_rotate(value);
  // @@protoc_insertion_point(field_set:Message.Game_tankinfo_Request.rotate)
}

// int32 tank_style = 4;
inline void Game_tankinfo_Request::clear_tank_style() {
  _impl_.tank_style_ = 0;
}
inline int32_t Game_tankinfo_Request::_internal_tank_style() const {
  return _impl_.tank_style_;
}
inline int32_t Game_tankinfo_Request::tank_style() const {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Request.tank_style)
  return _internal_tank_style();
}
inline void Game_tankinfo_Request::_internal_set_tank_style(int32_t value) {
  
  _impl_.tank_style_ = value;
}
inline void Game_tankinfo_Request::set_tank_style(int32_t value) {
  _internal_set_tank_style(value);
  // @@protoc_insertion_point(field_set:Message.Game_tankinfo_Request.tank_style)
}

// -------------------------------------------------------------------

// Game_tankinfo_Response_tankinfo

// int32 id = 1;
inline void Game_tankinfo_Response_tankinfo::clear_id() {
  _impl_.id_ = 0;
}
inline int32_t Game_tankinfo_Response_tankinfo::_internal_id() const {
  return _impl_.id_;
}
inline int32_t Game_tankinfo_Response_tankinfo::id() const {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Response.tankinfo.id)
  return _internal_id();
}
inline void Game_tankinfo_Response_tankinfo::_internal_set_id(int32_t value) {
  
  _impl_.id_ = value;
}
inline void Game_tankinfo_Response_tankinfo::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_tankinfo_Response.tankinfo.id)
}

// .Message.Game_tankinfo_Request tankinfo = 2;
inline bool Game_tankinfo_Response_tankinfo::_internal_has_tankinfo() const {
  return this != internal_default_instance() && _impl_.tankinfo_ != nullptr;
}
inline bool Game_tankinfo_Response_tankinfo::has_tankinfo() const {
  return _internal_has_tankinfo();
}
inline void Game_tankinfo_Response_tankinfo::clear_tankinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.tankinfo_ != nullptr) {
    delete _impl_.tankinfo_;
  }
  _impl_.tankinfo_ = nullptr;
}
inline const ::Message::Game_tankinfo_Request& Game_tankinfo_Response_tankinfo::_internal_tankinfo() const {
  const ::Message::Game_tankinfo_Request* p = _impl_.tankinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Message::Game_tankinfo_Request&>(
      ::Message::_Game_tankinfo_Request_default_instance_);
}
inline const ::Message::Game_tankinfo_Request& Game_tankinfo_Response_tankinfo::tankinfo() const {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Response.tankinfo.tankinfo)
  return _internal_tankinfo();
}
inline void Game_tankinfo_Response_tankinfo::unsafe_arena_set_allocated_tankinfo(
    ::Message::Game_tankinfo_Request* tankinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tankinfo_);
  }
  _impl_.tankinfo_ = tankinfo;
  if (tankinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Message.Game_tankinfo_Response.tankinfo.tankinfo)
}
inline ::Message::Game_tankinfo_Request* Game_tankinfo_Response_tankinfo::release_tankinfo() {
  
  ::Message::Game_tankinfo_Request* temp = _impl_.tankinfo_;
  _impl_.tankinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Message::Game_tankinfo_Request* Game_tankinfo_Response_tankinfo::unsafe_arena_release_tankinfo() {
  // @@protoc_insertion_point(field_release:Message.Game_tankinfo_Response.tankinfo.tankinfo)
  
  ::Message::Game_tankinfo_Request* temp = _impl_.tankinfo_;
  _impl_.tankinfo_ = nullptr;
  return temp;
}
inline ::Message::Game_tankinfo_Request* Game_tankinfo_Response_tankinfo::_internal_mutable_tankinfo() {
  
  if (_impl_.tankinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Message::Game_tankinfo_Request>(GetArenaForAllocation());
    _impl_.tankinfo_ = p;
  }
  return _impl_.tankinfo_;
}
inline ::Message::Game_tankinfo_Request* Game_tankinfo_Response_tankinfo::mutable_tankinfo() {
  ::Message::Game_tankinfo_Request* _msg = _internal_mutable_tankinfo();
  // @@protoc_insertion_point(field_mutable:Message.Game_tankinfo_Response.tankinfo.tankinfo)
  return _msg;
}
inline void Game_tankinfo_Response_tankinfo::set_allocated_tankinfo(::Message::Game_tankinfo_Request* tankinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.tankinfo_;
  }
  if (tankinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tankinfo);
    if (message_arena != submessage_arena) {
      tankinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tankinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tankinfo_ = tankinfo;
  // @@protoc_insertion_point(field_set_allocated:Message.Game_tankinfo_Response.tankinfo.tankinfo)
}

// int32 health = 3;
inline void Game_tankinfo_Response_tankinfo::clear_health() {
  _impl_.health_ = 0;
}
inline int32_t Game_tankinfo_Response_tankinfo::_internal_health() const {
  return _impl_.health_;
}
inline int32_t Game_tankinfo_Response_tankinfo::health() const {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Response.tankinfo.health)
  return _internal_health();
}
inline void Game_tankinfo_Response_tankinfo::_internal_set_health(int32_t value) {
  
  _impl_.health_ = value;
}
inline void Game_tankinfo_Response_tankinfo::set_health(int32_t value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:Message.Game_tankinfo_Response.tankinfo.health)
}

// -------------------------------------------------------------------

// Game_tankinfo_Response

// repeated .Message.Game_tankinfo_Response.tankinfo info = 1;
inline int Game_tankinfo_Response::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int Game_tankinfo_Response::info_size() const {
  return _internal_info_size();
}
inline void Game_tankinfo_Response::clear_info() {
  _impl_.info_.Clear();
}
inline ::Message::Game_tankinfo_Response_tankinfo* Game_tankinfo_Response::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:Message.Game_tankinfo_Response.info)
  return _impl_.info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Game_tankinfo_Response_tankinfo >*
Game_tankinfo_Response::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:Message.Game_tankinfo_Response.info)
  return &_impl_.info_;
}
inline const ::Message::Game_tankinfo_Response_tankinfo& Game_tankinfo_Response::_internal_info(int index) const {
  return _impl_.info_.Get(index);
}
inline const ::Message::Game_tankinfo_Response_tankinfo& Game_tankinfo_Response::info(int index) const {
  // @@protoc_insertion_point(field_get:Message.Game_tankinfo_Response.info)
  return _internal_info(index);
}
inline ::Message::Game_tankinfo_Response_tankinfo* Game_tankinfo_Response::_internal_add_info() {
  return _impl_.info_.Add();
}
inline ::Message::Game_tankinfo_Response_tankinfo* Game_tankinfo_Response::add_info() {
  ::Message::Game_tankinfo_Response_tankinfo* _add = _internal_add_info();
  // @@protoc_insertion_point(field_add:Message.Game_tankinfo_Response.info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Game_tankinfo_Response_tankinfo >&
Game_tankinfo_Response::info() const {
  // @@protoc_insertion_point(field_list:Message.Game_tankinfo_Response.info)
  return _impl_.info_;
}

// -------------------------------------------------------------------

// bulletinfo

// double locationX = 1;
inline void bulletinfo::clear_locationx() {
  _impl_.locationx_ = 0;
}
inline double bulletinfo::_internal_locationx() const {
  return _impl_.locationx_;
}
inline double bulletinfo::locationx() const {
  // @@protoc_insertion_point(field_get:Message.bulletinfo.locationX)
  return _internal_locationx();
}
inline void bulletinfo::_internal_set_locationx(double value) {
  
  _impl_.locationx_ = value;
}
inline void bulletinfo::set_locationx(double value) {
  _internal_set_locationx(value);
  // @@protoc_insertion_point(field_set:Message.bulletinfo.locationX)
}

// double locationY = 2;
inline void bulletinfo::clear_locationy() {
  _impl_.locationy_ = 0;
}
inline double bulletinfo::_internal_locationy() const {
  return _impl_.locationy_;
}
inline double bulletinfo::locationy() const {
  // @@protoc_insertion_point(field_get:Message.bulletinfo.locationY)
  return _internal_locationy();
}
inline void bulletinfo::_internal_set_locationy(double value) {
  
  _impl_.locationy_ = value;
}
inline void bulletinfo::set_locationy(double value) {
  _internal_set_locationy(value);
  // @@protoc_insertion_point(field_set:Message.bulletinfo.locationY)
}

// double rotate = 3;
inline void bulletinfo::clear_rotate() {
  _impl_.rotate_ = 0;
}
inline double bulletinfo::_internal_rotate() const {
  return _impl_.rotate_;
}
inline double bulletinfo::rotate() const {
  // @@protoc_insertion_point(field_get:Message.bulletinfo.rotate)
  return _internal_rotate();
}
inline void bulletinfo::_internal_set_rotate(double value) {
  
  _impl_.rotate_ = value;
}
inline void bulletinfo::set_rotate(double value) {
  _internal_set_rotate(value);
  // @@protoc_insertion_point(field_set:Message.bulletinfo.rotate)
}

// int32 bullet_style = 4;
inline void bulletinfo::clear_bullet_style() {
  _impl_.bullet_style_ = 0;
}
inline int32_t bulletinfo::_internal_bullet_style() const {
  return _impl_.bullet_style_;
}
inline int32_t bulletinfo::bullet_style() const {
  // @@protoc_insertion_point(field_get:Message.bulletinfo.bullet_style)
  return _internal_bullet_style();
}
inline void bulletinfo::_internal_set_bullet_style(int32_t value) {
  
  _impl_.bullet_style_ = value;
}
inline void bulletinfo::set_bullet_style(int32_t value) {
  _internal_set_bullet_style(value);
  // @@protoc_insertion_point(field_set:Message.bulletinfo.bullet_style)
}

// -------------------------------------------------------------------

// Game_bulletinfo_Request

// repeated .Message.bulletinfo bulletinfo = 2;
inline int Game_bulletinfo_Request::_internal_bulletinfo_size() const {
  return _impl_.bulletinfo_.size();
}
inline int Game_bulletinfo_Request::bulletinfo_size() const {
  return _internal_bulletinfo_size();
}
inline void Game_bulletinfo_Request::clear_bulletinfo() {
  _impl_.bulletinfo_.Clear();
}
inline ::Message::bulletinfo* Game_bulletinfo_Request::mutable_bulletinfo(int index) {
  // @@protoc_insertion_point(field_mutable:Message.Game_bulletinfo_Request.bulletinfo)
  return _impl_.bulletinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::bulletinfo >*
Game_bulletinfo_Request::mutable_bulletinfo() {
  // @@protoc_insertion_point(field_mutable_list:Message.Game_bulletinfo_Request.bulletinfo)
  return &_impl_.bulletinfo_;
}
inline const ::Message::bulletinfo& Game_bulletinfo_Request::_internal_bulletinfo(int index) const {
  return _impl_.bulletinfo_.Get(index);
}
inline const ::Message::bulletinfo& Game_bulletinfo_Request::bulletinfo(int index) const {
  // @@protoc_insertion_point(field_get:Message.Game_bulletinfo_Request.bulletinfo)
  return _internal_bulletinfo(index);
}
inline ::Message::bulletinfo* Game_bulletinfo_Request::_internal_add_bulletinfo() {
  return _impl_.bulletinfo_.Add();
}
inline ::Message::bulletinfo* Game_bulletinfo_Request::add_bulletinfo() {
  ::Message::bulletinfo* _add = _internal_add_bulletinfo();
  // @@protoc_insertion_point(field_add:Message.Game_bulletinfo_Request.bulletinfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::bulletinfo >&
Game_bulletinfo_Request::bulletinfo() const {
  // @@protoc_insertion_point(field_list:Message.Game_bulletinfo_Request.bulletinfo)
  return _impl_.bulletinfo_;
}

// -------------------------------------------------------------------

// Game_bulletinfo_Response_Info

// int32 tankid = 1;
inline void Game_bulletinfo_Response_Info::clear_tankid() {
  _impl_.tankid_ = 0;
}
inline int32_t Game_bulletinfo_Response_Info::_internal_tankid() const {
  return _impl_.tankid_;
}
inline int32_t Game_bulletinfo_Response_Info::tankid() const {
  // @@protoc_insertion_point(field_get:Message.Game_bulletinfo_Response.Info.tankid)
  return _internal_tankid();
}
inline void Game_bulletinfo_Response_Info::_internal_set_tankid(int32_t value) {
  
  _impl_.tankid_ = value;
}
inline void Game_bulletinfo_Response_Info::set_tankid(int32_t value) {
  _internal_set_tankid(value);
  // @@protoc_insertion_point(field_set:Message.Game_bulletinfo_Response.Info.tankid)
}

// repeated .Message.bulletinfo bulletinfo = 2;
inline int Game_bulletinfo_Response_Info::_internal_bulletinfo_size() const {
  return _impl_.bulletinfo_.size();
}
inline int Game_bulletinfo_Response_Info::bulletinfo_size() const {
  return _internal_bulletinfo_size();
}
inline void Game_bulletinfo_Response_Info::clear_bulletinfo() {
  _impl_.bulletinfo_.Clear();
}
inline ::Message::bulletinfo* Game_bulletinfo_Response_Info::mutable_bulletinfo(int index) {
  // @@protoc_insertion_point(field_mutable:Message.Game_bulletinfo_Response.Info.bulletinfo)
  return _impl_.bulletinfo_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::bulletinfo >*
Game_bulletinfo_Response_Info::mutable_bulletinfo() {
  // @@protoc_insertion_point(field_mutable_list:Message.Game_bulletinfo_Response.Info.bulletinfo)
  return &_impl_.bulletinfo_;
}
inline const ::Message::bulletinfo& Game_bulletinfo_Response_Info::_internal_bulletinfo(int index) const {
  return _impl_.bulletinfo_.Get(index);
}
inline const ::Message::bulletinfo& Game_bulletinfo_Response_Info::bulletinfo(int index) const {
  // @@protoc_insertion_point(field_get:Message.Game_bulletinfo_Response.Info.bulletinfo)
  return _internal_bulletinfo(index);
}
inline ::Message::bulletinfo* Game_bulletinfo_Response_Info::_internal_add_bulletinfo() {
  return _impl_.bulletinfo_.Add();
}
inline ::Message::bulletinfo* Game_bulletinfo_Response_Info::add_bulletinfo() {
  ::Message::bulletinfo* _add = _internal_add_bulletinfo();
  // @@protoc_insertion_point(field_add:Message.Game_bulletinfo_Response.Info.bulletinfo)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::bulletinfo >&
Game_bulletinfo_Response_Info::bulletinfo() const {
  // @@protoc_insertion_point(field_list:Message.Game_bulletinfo_Response.Info.bulletinfo)
  return _impl_.bulletinfo_;
}

// -------------------------------------------------------------------

// Game_bulletinfo_Response

// repeated .Message.Game_bulletinfo_Response.Info info = 1;
inline int Game_bulletinfo_Response::_internal_info_size() const {
  return _impl_.info_.size();
}
inline int Game_bulletinfo_Response::info_size() const {
  return _internal_info_size();
}
inline void Game_bulletinfo_Response::clear_info() {
  _impl_.info_.Clear();
}
inline ::Message::Game_bulletinfo_Response_Info* Game_bulletinfo_Response::mutable_info(int index) {
  // @@protoc_insertion_point(field_mutable:Message.Game_bulletinfo_Response.info)
  return _impl_.info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Game_bulletinfo_Response_Info >*
Game_bulletinfo_Response::mutable_info() {
  // @@protoc_insertion_point(field_mutable_list:Message.Game_bulletinfo_Response.info)
  return &_impl_.info_;
}
inline const ::Message::Game_bulletinfo_Response_Info& Game_bulletinfo_Response::_internal_info(int index) const {
  return _impl_.info_.Get(index);
}
inline const ::Message::Game_bulletinfo_Response_Info& Game_bulletinfo_Response::info(int index) const {
  // @@protoc_insertion_point(field_get:Message.Game_bulletinfo_Response.info)
  return _internal_info(index);
}
inline ::Message::Game_bulletinfo_Response_Info* Game_bulletinfo_Response::_internal_add_info() {
  return _impl_.info_.Add();
}
inline ::Message::Game_bulletinfo_Response_Info* Game_bulletinfo_Response::add_info() {
  ::Message::Game_bulletinfo_Response_Info* _add = _internal_add_info();
  // @@protoc_insertion_point(field_add:Message.Game_bulletinfo_Response.info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Message::Game_bulletinfo_Response_Info >&
Game_bulletinfo_Response::info() const {
  // @@protoc_insertion_point(field_list:Message.Game_bulletinfo_Response.info)
  return _impl_.info_;
}

// -------------------------------------------------------------------

// Game_hit_brick_Request

// int32 hited_brick_id = 1;
inline void Game_hit_brick_Request::clear_hited_brick_id() {
  _impl_.hited_brick_id_ = 0;
}
inline int32_t Game_hit_brick_Request::_internal_hited_brick_id() const {
  return _impl_.hited_brick_id_;
}
inline int32_t Game_hit_brick_Request::hited_brick_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_hit_brick_Request.hited_brick_id)
  return _internal_hited_brick_id();
}
inline void Game_hit_brick_Request::_internal_set_hited_brick_id(int32_t value) {
  
  _impl_.hited_brick_id_ = value;
}
inline void Game_hit_brick_Request::set_hited_brick_id(int32_t value) {
  _internal_set_hited_brick_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_hit_brick_Request.hited_brick_id)
}

// .Message.bulletinfo bulletinfo = 2;
inline bool Game_hit_brick_Request::_internal_has_bulletinfo() const {
  return this != internal_default_instance() && _impl_.bulletinfo_ != nullptr;
}
inline bool Game_hit_brick_Request::has_bulletinfo() const {
  return _internal_has_bulletinfo();
}
inline void Game_hit_brick_Request::clear_bulletinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.bulletinfo_ != nullptr) {
    delete _impl_.bulletinfo_;
  }
  _impl_.bulletinfo_ = nullptr;
}
inline const ::Message::bulletinfo& Game_hit_brick_Request::_internal_bulletinfo() const {
  const ::Message::bulletinfo* p = _impl_.bulletinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Message::bulletinfo&>(
      ::Message::_bulletinfo_default_instance_);
}
inline const ::Message::bulletinfo& Game_hit_brick_Request::bulletinfo() const {
  // @@protoc_insertion_point(field_get:Message.Game_hit_brick_Request.bulletinfo)
  return _internal_bulletinfo();
}
inline void Game_hit_brick_Request::unsafe_arena_set_allocated_bulletinfo(
    ::Message::bulletinfo* bulletinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bulletinfo_);
  }
  _impl_.bulletinfo_ = bulletinfo;
  if (bulletinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Message.Game_hit_brick_Request.bulletinfo)
}
inline ::Message::bulletinfo* Game_hit_brick_Request::release_bulletinfo() {
  
  ::Message::bulletinfo* temp = _impl_.bulletinfo_;
  _impl_.bulletinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Message::bulletinfo* Game_hit_brick_Request::unsafe_arena_release_bulletinfo() {
  // @@protoc_insertion_point(field_release:Message.Game_hit_brick_Request.bulletinfo)
  
  ::Message::bulletinfo* temp = _impl_.bulletinfo_;
  _impl_.bulletinfo_ = nullptr;
  return temp;
}
inline ::Message::bulletinfo* Game_hit_brick_Request::_internal_mutable_bulletinfo() {
  
  if (_impl_.bulletinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Message::bulletinfo>(GetArenaForAllocation());
    _impl_.bulletinfo_ = p;
  }
  return _impl_.bulletinfo_;
}
inline ::Message::bulletinfo* Game_hit_brick_Request::mutable_bulletinfo() {
  ::Message::bulletinfo* _msg = _internal_mutable_bulletinfo();
  // @@protoc_insertion_point(field_mutable:Message.Game_hit_brick_Request.bulletinfo)
  return _msg;
}
inline void Game_hit_brick_Request::set_allocated_bulletinfo(::Message::bulletinfo* bulletinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bulletinfo_;
  }
  if (bulletinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bulletinfo);
    if (message_arena != submessage_arena) {
      bulletinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bulletinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bulletinfo_ = bulletinfo;
  // @@protoc_insertion_point(field_set_allocated:Message.Game_hit_brick_Request.bulletinfo)
}

// -------------------------------------------------------------------

// Game_brick_hited_Response

// int32 hited_brick_id = 1;
inline void Game_brick_hited_Response::clear_hited_brick_id() {
  _impl_.hited_brick_id_ = 0;
}
inline int32_t Game_brick_hited_Response::_internal_hited_brick_id() const {
  return _impl_.hited_brick_id_;
}
inline int32_t Game_brick_hited_Response::hited_brick_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_brick_hited_Response.hited_brick_id)
  return _internal_hited_brick_id();
}
inline void Game_brick_hited_Response::_internal_set_hited_brick_id(int32_t value) {
  
  _impl_.hited_brick_id_ = value;
}
inline void Game_brick_hited_Response::set_hited_brick_id(int32_t value) {
  _internal_set_hited_brick_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_brick_hited_Response.hited_brick_id)
}

// int32 health = 2;
inline void Game_brick_hited_Response::clear_health() {
  _impl_.health_ = 0;
}
inline int32_t Game_brick_hited_Response::_internal_health() const {
  return _impl_.health_;
}
inline int32_t Game_brick_hited_Response::health() const {
  // @@protoc_insertion_point(field_get:Message.Game_brick_hited_Response.health)
  return _internal_health();
}
inline void Game_brick_hited_Response::_internal_set_health(int32_t value) {
  
  _impl_.health_ = value;
}
inline void Game_brick_hited_Response::set_health(int32_t value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:Message.Game_brick_hited_Response.health)
}

// -------------------------------------------------------------------

// Game_hit_tank_Request

// int32 hited_tank_id = 1;
inline void Game_hit_tank_Request::clear_hited_tank_id() {
  _impl_.hited_tank_id_ = 0;
}
inline int32_t Game_hit_tank_Request::_internal_hited_tank_id() const {
  return _impl_.hited_tank_id_;
}
inline int32_t Game_hit_tank_Request::hited_tank_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_hit_tank_Request.hited_tank_id)
  return _internal_hited_tank_id();
}
inline void Game_hit_tank_Request::_internal_set_hited_tank_id(int32_t value) {
  
  _impl_.hited_tank_id_ = value;
}
inline void Game_hit_tank_Request::set_hited_tank_id(int32_t value) {
  _internal_set_hited_tank_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_hit_tank_Request.hited_tank_id)
}

// .Message.bulletinfo bulletinfo = 2;
inline bool Game_hit_tank_Request::_internal_has_bulletinfo() const {
  return this != internal_default_instance() && _impl_.bulletinfo_ != nullptr;
}
inline bool Game_hit_tank_Request::has_bulletinfo() const {
  return _internal_has_bulletinfo();
}
inline void Game_hit_tank_Request::clear_bulletinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.bulletinfo_ != nullptr) {
    delete _impl_.bulletinfo_;
  }
  _impl_.bulletinfo_ = nullptr;
}
inline const ::Message::bulletinfo& Game_hit_tank_Request::_internal_bulletinfo() const {
  const ::Message::bulletinfo* p = _impl_.bulletinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Message::bulletinfo&>(
      ::Message::_bulletinfo_default_instance_);
}
inline const ::Message::bulletinfo& Game_hit_tank_Request::bulletinfo() const {
  // @@protoc_insertion_point(field_get:Message.Game_hit_tank_Request.bulletinfo)
  return _internal_bulletinfo();
}
inline void Game_hit_tank_Request::unsafe_arena_set_allocated_bulletinfo(
    ::Message::bulletinfo* bulletinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bulletinfo_);
  }
  _impl_.bulletinfo_ = bulletinfo;
  if (bulletinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Message.Game_hit_tank_Request.bulletinfo)
}
inline ::Message::bulletinfo* Game_hit_tank_Request::release_bulletinfo() {
  
  ::Message::bulletinfo* temp = _impl_.bulletinfo_;
  _impl_.bulletinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Message::bulletinfo* Game_hit_tank_Request::unsafe_arena_release_bulletinfo() {
  // @@protoc_insertion_point(field_release:Message.Game_hit_tank_Request.bulletinfo)
  
  ::Message::bulletinfo* temp = _impl_.bulletinfo_;
  _impl_.bulletinfo_ = nullptr;
  return temp;
}
inline ::Message::bulletinfo* Game_hit_tank_Request::_internal_mutable_bulletinfo() {
  
  if (_impl_.bulletinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Message::bulletinfo>(GetArenaForAllocation());
    _impl_.bulletinfo_ = p;
  }
  return _impl_.bulletinfo_;
}
inline ::Message::bulletinfo* Game_hit_tank_Request::mutable_bulletinfo() {
  ::Message::bulletinfo* _msg = _internal_mutable_bulletinfo();
  // @@protoc_insertion_point(field_mutable:Message.Game_hit_tank_Request.bulletinfo)
  return _msg;
}
inline void Game_hit_tank_Request::set_allocated_bulletinfo(::Message::bulletinfo* bulletinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bulletinfo_;
  }
  if (bulletinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bulletinfo);
    if (message_arena != submessage_arena) {
      bulletinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bulletinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.bulletinfo_ = bulletinfo;
  // @@protoc_insertion_point(field_set_allocated:Message.Game_hit_tank_Request.bulletinfo)
}

// -------------------------------------------------------------------

// Game_tank_hited_Response

// int32 hited_tank_id = 1;
inline void Game_tank_hited_Response::clear_hited_tank_id() {
  _impl_.hited_tank_id_ = 0;
}
inline int32_t Game_tank_hited_Response::_internal_hited_tank_id() const {
  return _impl_.hited_tank_id_;
}
inline int32_t Game_tank_hited_Response::hited_tank_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_tank_hited_Response.hited_tank_id)
  return _internal_hited_tank_id();
}
inline void Game_tank_hited_Response::_internal_set_hited_tank_id(int32_t value) {
  
  _impl_.hited_tank_id_ = value;
}
inline void Game_tank_hited_Response::set_hited_tank_id(int32_t value) {
  _internal_set_hited_tank_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_tank_hited_Response.hited_tank_id)
}

// int32 health = 2;
inline void Game_tank_hited_Response::clear_health() {
  _impl_.health_ = 0;
}
inline int32_t Game_tank_hited_Response::_internal_health() const {
  return _impl_.health_;
}
inline int32_t Game_tank_hited_Response::health() const {
  // @@protoc_insertion_point(field_get:Message.Game_tank_hited_Response.health)
  return _internal_health();
}
inline void Game_tank_hited_Response::_internal_set_health(int32_t value) {
  
  _impl_.health_ = value;
}
inline void Game_tank_hited_Response::set_health(int32_t value) {
  _internal_set_health(value);
  // @@protoc_insertion_point(field_set:Message.Game_tank_hited_Response.health)
}

// -------------------------------------------------------------------

// Game_destroyed_tank_Response

// int32 destroyed_tank_id = 1;
inline void Game_destroyed_tank_Response::clear_destroyed_tank_id() {
  _impl_.destroyed_tank_id_ = 0;
}
inline int32_t Game_destroyed_tank_Response::_internal_destroyed_tank_id() const {
  return _impl_.destroyed_tank_id_;
}
inline int32_t Game_destroyed_tank_Response::destroyed_tank_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_destroyed_tank_Response.destroyed_tank_id)
  return _internal_destroyed_tank_id();
}
inline void Game_destroyed_tank_Response::_internal_set_destroyed_tank_id(int32_t value) {
  
  _impl_.destroyed_tank_id_ = value;
}
inline void Game_destroyed_tank_Response::set_destroyed_tank_id(int32_t value) {
  _internal_set_destroyed_tank_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_destroyed_tank_Response.destroyed_tank_id)
}

// -------------------------------------------------------------------

// Game_create_prop

// int32 prop_type = 1;
inline void Game_create_prop::clear_prop_type() {
  _impl_.prop_type_ = 0;
}
inline int32_t Game_create_prop::_internal_prop_type() const {
  return _impl_.prop_type_;
}
inline int32_t Game_create_prop::prop_type() const {
  // @@protoc_insertion_point(field_get:Message.Game_create_prop.prop_type)
  return _internal_prop_type();
}
inline void Game_create_prop::_internal_set_prop_type(int32_t value) {
  
  _impl_.prop_type_ = value;
}
inline void Game_create_prop::set_prop_type(int32_t value) {
  _internal_set_prop_type(value);
  // @@protoc_insertion_point(field_set:Message.Game_create_prop.prop_type)
}

// double locationX = 2;
inline void Game_create_prop::clear_locationx() {
  _impl_.locationx_ = 0;
}
inline double Game_create_prop::_internal_locationx() const {
  return _impl_.locationx_;
}
inline double Game_create_prop::locationx() const {
  // @@protoc_insertion_point(field_get:Message.Game_create_prop.locationX)
  return _internal_locationx();
}
inline void Game_create_prop::_internal_set_locationx(double value) {
  
  _impl_.locationx_ = value;
}
inline void Game_create_prop::set_locationx(double value) {
  _internal_set_locationx(value);
  // @@protoc_insertion_point(field_set:Message.Game_create_prop.locationX)
}

// double locationY = 3;
inline void Game_create_prop::clear_locationy() {
  _impl_.locationy_ = 0;
}
inline double Game_create_prop::_internal_locationy() const {
  return _impl_.locationy_;
}
inline double Game_create_prop::locationy() const {
  // @@protoc_insertion_point(field_get:Message.Game_create_prop.locationY)
  return _internal_locationy();
}
inline void Game_create_prop::_internal_set_locationy(double value) {
  
  _impl_.locationy_ = value;
}
inline void Game_create_prop::set_locationy(double value) {
  _internal_set_locationy(value);
  // @@protoc_insertion_point(field_set:Message.Game_create_prop.locationY)
}

// -------------------------------------------------------------------

// Game_getProp_Request

// int32 prop_id = 1;
inline void Game_getProp_Request::clear_prop_id() {
  _impl_.prop_id_ = 0;
}
inline int32_t Game_getProp_Request::_internal_prop_id() const {
  return _impl_.prop_id_;
}
inline int32_t Game_getProp_Request::prop_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_getProp_Request.prop_id)
  return _internal_prop_id();
}
inline void Game_getProp_Request::_internal_set_prop_id(int32_t value) {
  
  _impl_.prop_id_ = value;
}
inline void Game_getProp_Request::set_prop_id(int32_t value) {
  _internal_set_prop_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_getProp_Request.prop_id)
}

// -------------------------------------------------------------------

// Game_prop_Response

// int32 prop_id = 1;
inline void Game_prop_Response::clear_prop_id() {
  _impl_.prop_id_ = 0;
}
inline int32_t Game_prop_Response::_internal_prop_id() const {
  return _impl_.prop_id_;
}
inline int32_t Game_prop_Response::prop_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_prop_Response.prop_id)
  return _internal_prop_id();
}
inline void Game_prop_Response::_internal_set_prop_id(int32_t value) {
  
  _impl_.prop_id_ = value;
}
inline void Game_prop_Response::set_prop_id(int32_t value) {
  _internal_set_prop_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_prop_Response.prop_id)
}

// int32 tank_id = 2;
inline void Game_prop_Response::clear_tank_id() {
  _impl_.tank_id_ = 0;
}
inline int32_t Game_prop_Response::_internal_tank_id() const {
  return _impl_.tank_id_;
}
inline int32_t Game_prop_Response::tank_id() const {
  // @@protoc_insertion_point(field_get:Message.Game_prop_Response.tank_id)
  return _internal_tank_id();
}
inline void Game_prop_Response::_internal_set_tank_id(int32_t value) {
  
  _impl_.tank_id_ = value;
}
inline void Game_prop_Response::set_tank_id(int32_t value) {
  _internal_set_tank_id(value);
  // @@protoc_insertion_point(field_set:Message.Game_prop_Response.tank_id)
}

// -------------------------------------------------------------------

// UDP_INFO_REQ

// string ip = 1;
inline void UDP_INFO_REQ::clear_ip() {
  _impl_.ip_.ClearToEmpty();
}
inline const std::string& UDP_INFO_REQ::ip() const {
  // @@protoc_insertion_point(field_get:Message.UDP_INFO_REQ.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void UDP_INFO_REQ::set_ip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Message.UDP_INFO_REQ.ip)
}
inline std::string* UDP_INFO_REQ::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:Message.UDP_INFO_REQ.ip)
  return _s;
}
inline const std::string& UDP_INFO_REQ::_internal_ip() const {
  return _impl_.ip_.Get();
}
inline void UDP_INFO_REQ::_internal_set_ip(const std::string& value) {
  
  _impl_.ip_.Set(value, GetArenaForAllocation());
}
inline std::string* UDP_INFO_REQ::_internal_mutable_ip() {
  
  return _impl_.ip_.Mutable(GetArenaForAllocation());
}
inline std::string* UDP_INFO_REQ::release_ip() {
  // @@protoc_insertion_point(field_release:Message.UDP_INFO_REQ.ip)
  return _impl_.ip_.Release();
}
inline void UDP_INFO_REQ::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  _impl_.ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ip_.IsDefault()) {
    _impl_.ip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Message.UDP_INFO_REQ.ip)
}

// int32 port = 2;
inline void UDP_INFO_REQ::clear_port() {
  _impl_.port_ = 0;
}
inline int32_t UDP_INFO_REQ::_internal_port() const {
  return _impl_.port_;
}
inline int32_t UDP_INFO_REQ::port() const {
  // @@protoc_insertion_point(field_get:Message.UDP_INFO_REQ.port)
  return _internal_port();
}
inline void UDP_INFO_REQ::_internal_set_port(int32_t value) {
  
  _impl_.port_ = value;
}
inline void UDP_INFO_REQ::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Message.UDP_INFO_REQ.port)
}

// -------------------------------------------------------------------

// UDP_INFO_RES

// bool OK = 1;
inline void UDP_INFO_RES::clear_ok() {
  _impl_.ok_ = false;
}
inline bool UDP_INFO_RES::_internal_ok() const {
  return _impl_.ok_;
}
inline bool UDP_INFO_RES::ok() const {
  // @@protoc_insertion_point(field_get:Message.UDP_INFO_RES.OK)
  return _internal_ok();
}
inline void UDP_INFO_RES::_internal_set_ok(bool value) {
  
  _impl_.ok_ = value;
}
inline void UDP_INFO_RES::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:Message.UDP_INFO_RES.OK)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Message

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_myprotocol_2eproto
